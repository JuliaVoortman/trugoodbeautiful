// src/requests/exceptions.ts
var ExpiredRequestException = class extends Error {
  constructor(ttl) {
    super();
    this.ttl = ttl;
    this.message = `[${this.constructor.name}]: Requests are expected to be verified within ${this.ttl}s from their signature.`;
  }
};

// src/requests/sign-request.ts
import * as crypto from "crypto";

// src/requests/typings/function.ts
var FunctionTypeEnum = /* @__PURE__ */ ((FunctionTypeEnum2) => {
  FunctionTypeEnum2["GraphqlFieldMapping"] = "graphql.field.mapping";
  FunctionTypeEnum2["GraphqlResourceTypeMapping"] = "graphql.resourcetype.mapping";
  FunctionTypeEnum2["GraphqlQuery"] = "graphql.query";
  FunctionTypeEnum2["AppEventFilter"] = "appevent.filter";
  FunctionTypeEnum2["AppEventHandler"] = "appevent.handler";
  FunctionTypeEnum2["AppEventTransformation"] = "appevent.transformation";
  FunctionTypeEnum2["AppActionCall"] = "appaction.call";
  FunctionTypeEnum2["ResourcesSearch"] = "resources.search";
  FunctionTypeEnum2["ResourcesLookup"] = "resources.lookup";
  return FunctionTypeEnum2;
})(FunctionTypeEnum || {});

// src/requests/typings/request.ts
var ContentfulHeader = /* @__PURE__ */ ((ContentfulHeader2) => {
  ContentfulHeader2["Timestamp"] = "x-contentful-timestamp";
  ContentfulHeader2["SignedHeaders"] = "x-contentful-signed-headers";
  ContentfulHeader2["Signature"] = "x-contentful-signature";
  return ContentfulHeader2;
})(ContentfulHeader || {});
var ContentfulContextHeader = /* @__PURE__ */ ((ContentfulContextHeader2) => {
  ContentfulContextHeader2["CRN"] = "x-contentful-crn";
  ContentfulContextHeader2["SpaceId"] = "x-contentful-space-id";
  ContentfulContextHeader2["EnvironmentId"] = "x-contentful-environment-id";
  ContentfulContextHeader2["UserId"] = "x-contentful-user-id";
  ContentfulContextHeader2["AppId"] = "x-contentful-app-id";
  return ContentfulContextHeader2;
})(ContentfulContextHeader || {});

// src/requests/typings/validators.ts
import * as runtypes from "runtypes";
var MethodValidator = runtypes.Union(
  runtypes.Literal("GET"),
  runtypes.Literal("PATCH"),
  runtypes.Literal("HEAD"),
  runtypes.Literal("POST"),
  runtypes.Literal("DELETE"),
  runtypes.Literal("OPTIONS"),
  runtypes.Literal("PUT")
);
var PathValidator = runtypes.String.withConstraint((s) => s.startsWith("/"), {
  name: "CanonicalURI"
});
var SignatureValidator = runtypes.String.withConstraint((s) => s.length === 64, {
  name: "SignatureLength"
});
var CanonicalRequestValidator = runtypes.Record({
  method: MethodValidator,
  path: PathValidator
}).And(
  runtypes.Partial({
    headers: runtypes.Dictionary(runtypes.String, "string"),
    body: runtypes.String
  })
);
var SecretValidator = runtypes.String.withConstraint((s) => s.length === 64, {
  name: "SecretLength"
});
var TimestampValidator = runtypes.Number.withConstraint((n) => n > 15778368e5, {
  name: "TimestampAge"
});
var SignedHeadersValidator = runtypes.Array(runtypes.String).withConstraint((l) => l.length >= 2, { name: "MissingTimestampOrSignedHeaders" });
var RequestMetadataValidator = runtypes.Record({
  signature: SignatureValidator,
  timestamp: TimestampValidator,
  signedHeaders: SignedHeadersValidator
});
var TimeToLiveValidator = runtypes.Number.withConstraint((n) => n >= 0, {
  name: "PositiveNumber"
});

// src/requests/utils.ts
import * as querystring from "querystring";
var getNormalizedEncodedURI = (uri) => {
  const [pathname, search] = uri.split("?");
  const escapedSearch = search ? querystring.escape(search) : "";
  return encodeURI(escapedSearch ? `${pathname}?${escapedSearch}` : pathname);
};
var sortHeaderKeys = (keyA, keyB) => keyA > keyB ? 1 : -1;
var normalizeHeaderKey = (key) => key.toLowerCase().trim();
var normalizeHeaderValue = (value) => value.trim();
var normalizeHeaders = (headers) => map(headers, ([key, value]) => [normalizeHeaderKey(key), normalizeHeaderValue(value)]);
var pickHeaders = (headers, keys) => {
  if (!headers) {
    return {};
  }
  if (!keys) {
    return headers;
  }
  return filter(headers, ([key]) => keys.includes(key));
};
var contextHeadersMap = {
  crn: "x-contentful-crn" /* CRN */,
  spaceId: "x-contentful-space-id" /* SpaceId */,
  envId: "x-contentful-environment-id" /* EnvironmentId */,
  appId: "x-contentful-app-id" /* AppId */,
  userId: "x-contentful-user-id" /* UserId */
};
function normalizeContextHeaders(rawContext) {
  return Object.keys(rawContext).reduce(
    (acc, header) => {
      if (contextHeadersMap[header]) {
        const key = normalizeHeaderKey(contextHeadersMap[header]);
        acc[key] = normalizeHeaderValue(
          acc[key] ?? rawContext[header]
        );
      }
      return acc;
    },
    {}
  );
}
var filter = (obj, callback) => {
  return Object.fromEntries(Object.entries(obj).filter(callback));
};
var map = (obj, callback) => {
  return Object.fromEntries(Object.entries(obj).map(callback));
};

// src/requests/sign-request.ts
var hash = (normalizedCanonicalRequest, secret) => {
  const stringifiedHeaders = normalizedCanonicalRequest.headers.map(([key, value]) => `${key}:${value}`).join(";");
  const stringifiedRequest = [
    normalizedCanonicalRequest.method,
    normalizedCanonicalRequest.path,
    stringifiedHeaders,
    normalizedCanonicalRequest.body
  ].join("\n");
  const hmac = crypto.createHmac("sha256", secret);
  hmac.update(stringifiedRequest);
  return hmac.digest("hex");
};
var getSortedAndSignedHeaders = (headers, timestamp) => {
  const rawSignedHeaders = Object.keys(headers);
  if (!("x-contentful-signed-headers" /* SignedHeaders */ in headers)) {
    rawSignedHeaders.push("x-contentful-signed-headers" /* SignedHeaders */);
  }
  if (!("x-contentful-timestamp" /* Timestamp */ in headers)) {
    rawSignedHeaders.push("x-contentful-timestamp" /* Timestamp */);
  }
  const signedHeaders = rawSignedHeaders.sort(sortHeaderKeys).join(",");
  headers["x-contentful-timestamp" /* Timestamp */] = timestamp.toString();
  headers["x-contentful-signed-headers" /* SignedHeaders */] = signedHeaders;
  const sortedHeaders = Object.entries(headers).sort(([keyA], [keyB]) => sortHeaderKeys(keyA, keyB));
  return { sortedHeaders, signedHeaders };
};
function signRequest(rawSecret, rawCanonicalRequest, rawTimestamp, rawContext) {
  const maybeDefaultTimestamp = rawTimestamp ?? Date.now();
  const canonicalRequest = CanonicalRequestValidator.check(rawCanonicalRequest);
  const timestamp = TimestampValidator.check(maybeDefaultTimestamp);
  const secret = SecretValidator.check(rawSecret);
  const path = getNormalizedEncodedURI(canonicalRequest.path);
  const method = canonicalRequest.method;
  const headers = canonicalRequest.headers ? normalizeHeaders(canonicalRequest.headers) : {};
  const body = canonicalRequest.body ?? "";
  const contextHeaders = rawContext ? normalizeContextHeaders(rawContext) : {};
  const { sortedHeaders, signedHeaders } = getSortedAndSignedHeaders(
    { ...headers, ...contextHeaders },
    timestamp
  );
  return {
    ["x-contentful-signature" /* Signature */]: hash({ method, headers: sortedHeaders, path, body }, secret),
    ["x-contentful-signed-headers" /* SignedHeaders */]: signedHeaders,
    ["x-contentful-timestamp" /* Timestamp */]: timestamp.toString(),
    ...contextHeaders
  };
}

// src/requests/verify-request.ts
var getRequestMetadata = (normalizedHeaders) => {
  const signature = normalizedHeaders["x-contentful-signature" /* Signature */];
  const signedHeaders = (normalizedHeaders["x-contentful-signed-headers" /* SignedHeaders */] ?? "").split(",");
  const timestamp = Number.parseInt(normalizedHeaders["x-contentful-timestamp" /* Timestamp */] ?? "", 10);
  return RequestMetadataValidator.check({ signature, signedHeaders, timestamp });
};
var isRequestTimestampTooOld = (ttl, timestamp) => {
  return Date.now() - timestamp >= ttl * 1e3;
};
var verifyRequest = (rawSecret, rawCanonicalRequest, rawTimeToLive = 30) => {
  const canonicalRequest = CanonicalRequestValidator.check(rawCanonicalRequest);
  const secret = SecretValidator.check(rawSecret);
  const normalizedHeaders = normalizeHeaders(canonicalRequest.headers ?? {});
  const { signature, signedHeaders, timestamp } = getRequestMetadata(normalizedHeaders);
  if (rawTimeToLive !== 0 && isRequestTimestampTooOld(rawTimeToLive, timestamp)) {
    throw new ExpiredRequestException(rawTimeToLive);
  }
  const requestToValidate = {
    ...canonicalRequest,
    headers: pickHeaders(normalizedHeaders, signedHeaders)
  };
  const { ["x-contentful-signature" /* Signature */]: computedSignature } = signRequest(
    secret,
    requestToValidate,
    timestamp
  );
  return signature === computedSignature;
};
export {
  CanonicalRequestValidator,
  ContentfulContextHeader,
  ContentfulHeader,
  ExpiredRequestException,
  FunctionTypeEnum,
  RequestMetadataValidator,
  SecretValidator,
  TimeToLiveValidator,
  TimestampValidator,
  signRequest,
  verifyRequest
};
//# sourceMappingURL=index.mjs.map