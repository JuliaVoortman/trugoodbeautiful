import { PlainClientAPI, AppActionCategoryType, AppInstallationProps, ReleaseProps, ReleaseActionProps, ScheduledActionProps, BulkActionProps, EnvironmentTemplateInstallationProps, WorkflowProps, CommentProps, TaskProps, Link, ContentTypeFieldValidation, ClientOptions } from 'contentful-management';
import * as runtypes from 'runtypes';

type AppActionCallContext = {
    cma: PlainClientAPI;
    appActionCallContext: {
        spaceId: string;
        environmentId: string;
        appInstallationId: string;
        userId: string;
        cmaHost: string;
        uploadHost: string;
    };
};
type AppActionCustomCategoryBody = Record<string, unknown>;
type AppActionEntriesV1CategoryBody = {
    entryIds: string;
};
type AppActionNotificationsV1CategoryBody = {
    message: string;
    recipient: string;
};
type AppActionCategoryBodyMap = {
    Custom: AppActionCustomCategoryBody;
    'Entries.v1.0': AppActionEntriesV1CategoryBody;
    'Notifications.v1.0': AppActionNotificationsV1CategoryBody;
};
type AppActionRequestBody<CategoryType extends AppActionCategoryType> = CategoryType extends keyof AppActionCategoryBodyMap ? AppActionCategoryBodyMap[CategoryType] : never;

type AppEventPayloadMap = {
    Entry: {
        create: EntryCreateEventPayload;
        save: EntrySaveEventPayload;
        auto_save: EntryAutosaveEventPayload;
        publish: EntryPublishEventPayload;
        unpublish: EntryUnpublishEventPayload;
        archive: EntryArchiveEventPayload;
        unarchive: EntryUnarchiveEventPayload;
        delete: EntryDeleteEventPayload;
    };
    Asset: {
        create: AssetCreateEventPayload;
        save: AssetSaveEventPayload;
        auto_save: AssetAutosaveEventPayload;
        publish: AssetPublishEventPayload;
        unpublish: AssetUnpublishEventPayload;
        archive: AssetArchiveEventPayload;
        unarchive: AssetUnarchiveEventPayload;
        delete: AssetDeleteEventPayload;
    };
    ContentType: {
        create: ContentTypeCreateEventPayload;
        save: ContentTypeSaveEventPayload;
        publish: ContentTypePublishEventPayload;
        unpublish: ContentTypeUnpublishEventPayload;
        delete: ContentTypeDeleteEventPayload;
    };
    Comment: {
        create: CreateCommentEventPayload;
        delete: DeleteCommentEventPayload;
    };
    Task: {
        create: CreateTaskEventPayload;
        save: SaveTaskEventPayload;
        delete: DeleteTaskEventPayload;
    };
    AppInstallation: {
        create: AppInstallationProps;
        save: AppInstallationProps;
        delete: AppInstallationProps;
    };
    Release: {
        create: ReleaseProps;
        save: ReleaseProps;
        delete: ReleaseProps;
    };
    ReleaseAction: {
        create: ReleaseActionProps;
        execute: ReleaseActionProps;
    };
    ScheduledAction: {
        create: ScheduledActionProps;
        save: ScheduledActionProps;
        delete: ScheduledActionProps;
        execute: ScheduledActionProps;
    };
    BulkAction: {
        create: BulkActionProps;
        execute: BulkActionProps;
    };
    TemplateInstallation: {
        complete: EnvironmentTemplateInstallationProps;
    };
    Workflow: {
        create: WorkflowProps;
        save: WorkflowProps;
        delete: WorkflowProps;
    };
};
interface Metadata {
    tags: Link<'Tag'>[];
    concepts: Link<'TaxonomyConcept'>[];
}
interface BasePublishableEntitySys<T extends 'Entry' | 'Asset' | 'ContentType'> {
    space: Link<'Space'>;
    id: string;
    type: T;
    createdAt: string;
    updatedAt: string;
    environment: Link<'Environment'>;
    createdBy: Link<'User'>;
    updatedBy: Link<'User'>;
    publishedCounter: number;
    version: number;
    urn: string;
}
interface BasePublishableDeliveryEntitySys<T extends 'Entry' | 'Asset'> extends BasePublishableEntitySys<T> {
    fieldStatus: {
        '*': {
            [locale: string]: string;
        };
    };
    automationTags: any[];
}
interface PublishedEntityAutosaveEventSysProps {
    publishedVersion: number;
    publishedAt: string;
    firstPublishedAt: string;
    publishedBy: Link<'User'>;
}
interface EntityArchiveEventSysProps {
    archivedAt: string;
    firstPublishedAt?: string;
    archivedBy: Link<'User'>;
    archivedVersion: number;
}
interface BaseEntityPublishEventSys<T extends 'Entry' | 'Asset' | 'ContentType'> {
    type: T;
    id: string;
    space: Link<'Space'>;
    environment: Link<'Environment'>;
    createdBy: Link<'User'>;
    updatedBy: Link<'User'>;
    revision: number;
    createdAt: string;
    updatedAt: string;
    publishedVersion: number;
}
interface BaseEntityDeleteEventSys<T extends 'Entry' | 'Asset' | 'ContentType'> {
    type: T;
    id: string;
    space: Link<'Space'>;
    environment: Link<'Environment'>;
    revision: number;
    createdAt: string;
    updatedAt: string;
    deletedAt: string;
    deletedBy: Link<'User'>;
}
interface BaseEntryEventPayload {
    metadata: Metadata;
    fields: EntryFields;
}
interface EntryFields {
    [fieldName: string]: {
        [locale: string]: string;
    };
}
interface BasePublishableEntrySys extends BasePublishableDeliveryEntitySys<'Entry'> {
    contentType: Link<'ContentType'>;
}
interface EntryCreateEventPayload extends BaseEntryEventPayload {
    sys: BasePublishableEntrySys;
}
interface EntryAutosaveEventPayload extends BaseEntryEventPayload {
    sys: BasePublishableEntrySys | (BasePublishableEntrySys & PublishedEntityAutosaveEventSysProps);
}
type EntrySaveEventPayload = EntryAutosaveEventPayload;
interface EntryPublishedEventSys extends BaseEntityPublishEventSys<'Entry'> {
    contentType: Link<'ContentType'>;
}
interface EntryPublishEventPayload extends BaseEntryEventPayload {
    sys: EntryPublishedEventSys;
}
interface EntryDeleteEventSys extends BaseEntityDeleteEventSys<'Entry'> {
    contentType: Link<'ContentType'>;
}
interface EntryDeleteEventPayload {
    sys: EntryDeleteEventSys;
}
type EntryUnpublishEventPayload = EntryDeleteEventPayload;
interface EntryArchiveEventPayload extends BaseEntryEventPayload {
    sys: BasePublishableEntrySys & EntityArchiveEventSysProps;
}
interface EntryUnarchiveEventPayload extends BaseEntryEventPayload {
    sys: BasePublishableEntrySys & {
        fistPublishedAt?: string;
    };
}
interface AssetFields {
    title: {
        [locale: string]: string;
    };
    description: {
        [locale: string]: string;
    };
    file: {
        [locale: string]: {
            fileName: string;
            uploadFrom: Link<'Upload'>;
            contentType: string;
        };
    };
}
interface AssetCreateEventPayload {
    metadata: Metadata;
    sys: BasePublishableDeliveryEntitySys<'Asset'>;
    fields: AssetFields;
}
interface AssetAutosaveEventPayload {
    metadata: Metadata;
    sys: BasePublishableDeliveryEntitySys<'Asset'> | (BasePublishableDeliveryEntitySys<'Asset'> & PublishedEntityAutosaveEventSysProps);
    fields: AssetFields;
}
type AssetSaveEventPayload = AssetAutosaveEventPayload;
interface AssetPublishEventPayload {
    metadata: Metadata;
    sys: BaseEntityPublishEventSys<'Asset'>;
    fields: AssetFields;
}
interface AssetDeleteEventPayload {
    sys: BaseEntityDeleteEventSys<'Asset'>;
}
type AssetUnpublishEventPayload = AssetDeleteEventPayload;
interface AssetArchiveEventPayload {
    metadata: Metadata;
    sys: BasePublishableDeliveryEntitySys<'Asset'> & EntityArchiveEventSysProps;
    fields: AssetFields;
}
interface AssetUnarchiveEventPayload {
    metadata: Metadata;
    sys: BasePublishableDeliveryEntitySys<'Asset'> & {
        fistPublishedAt?: string;
    };
    fields: AssetFields;
}
type ContentTypeFields = {
    id: string;
    name: string;
    type: string;
    localized: boolean;
    required: boolean;
    validations: ContentTypeFieldValidation[];
    disabled: boolean;
    omitted: boolean;
}[];
interface BaseContentTypePayload {
    displayField: string;
    name: string;
    description: string;
    fields: ContentTypeFields;
}
interface ContentTypeCreateEventPayload extends BaseContentTypePayload {
    sys: BasePublishableEntitySys<'ContentType'>;
}
interface ContentTypeSaveEventPayload extends BaseContentTypePayload {
    sys: BasePublishableEntitySys<'ContentType'> | (BasePublishableEntitySys<'ContentType'> & PublishedEntityAutosaveEventSysProps);
}
interface ContentTypePublishEventPayload extends BaseContentTypePayload {
    sys: BaseEntityPublishEventSys<'ContentType'>;
}
interface ContentTypeDeleteEventPayload {
    sys: BaseEntityDeleteEventSys<'ContentType'>;
}
type ContentTypeUnpublishEventPayload = ContentTypeDeleteEventPayload;
interface BaseCommentTaskEventSys {
    idempotencyId: string;
    user: Link<'User'>;
    environment: Link<'Environment'>;
    organization: Link<'Organization'>;
    space: Link<'Space'>;
}
interface CreateCommentEventPayload {
    sys: BaseCommentTaskEventSys & {
        newComment: CommentProps;
    };
    userAgent: string;
}
interface DeleteCommentEventPayload {
    sys: BaseCommentTaskEventSys & {
        oldComment: CommentProps;
    };
    userAgent: string;
}
interface CreateTaskEventPayload {
    sys: BaseCommentTaskEventSys & {
        newTask: TaskProps;
    };
    userAgent: string;
}
interface SaveTaskEventPayload {
    sys: BaseCommentTaskEventSys & {
        oldTask: TaskProps;
        newTask: TaskProps;
    };
    userAgent: string;
}
interface DeleteTaskEventPayload {
    sys: BaseCommentTaskEventSys & {
        oldTask: TaskProps;
    };
    userAgent: string;
}

type ResourcesSearchRequest = {
    type: FunctionTypeEnum.ResourcesSearch;
    resourceType: string;
    query?: string;
    locale?: string;
    limit: number;
    pages?: {
        nextCursor: string;
    };
};
type ResourcesSearchResponse<S extends Record<string, unknown> = Record<string, unknown>> = {
    items: S[];
    pages: {
        nextCursor?: string;
    };
};
type Scalar = string | number | boolean;
type ResourcesLookupRequest<L extends Record<string, Scalar[]> = Record<string, Scalar[]>> = {
    type: FunctionTypeEnum.ResourcesLookup;
    lookupBy: L;
    resourceType: string;
    locale?: string;
    limit: number;
    pages?: {
        nextCursor: string;
    };
};
type ResourcesLookupResponse<L extends Record<string, unknown> = Record<string, unknown>> = {
    items: L[];
    pages: {
        nextCursor?: string;
    };
};

declare enum FunctionTypeEnum {
    GraphqlFieldMapping = "graphql.field.mapping",
    GraphqlResourceTypeMapping = "graphql.resourcetype.mapping",
    GraphqlQuery = "graphql.query",
    AppEventFilter = "appevent.filter",
    AppEventHandler = "appevent.handler",
    AppEventTransformation = "appevent.transformation",
    AppActionCall = "appaction.call",
    ResourcesSearch = "resources.search",
    ResourcesLookup = "resources.lookup"
}
type GraphQLFieldTypeMappingRequest = {
    type: FunctionTypeEnum.GraphqlFieldMapping;
    fields: {
        contentTypeId: string;
        field: Field;
    }[];
};
type Field = {
    id: string;
    type: string;
};
type GraphQLFieldTypeMappingResponse = {
    namespace: string;
    fields: GraphQLFieldTypeMapping[];
};
type GraphQLFieldTypeMapping = {
    contentTypeId: string;
    fieldId: string;
    graphQLOutputType?: string;
    graphQLQueryField: string;
    graphQLQueryArguments: Record<string, string>;
};
type GraphQLResourceTypeMappingRequest = {
    type: FunctionTypeEnum.GraphqlResourceTypeMapping;
    resourceTypes: {
        resourceTypeId: string;
    }[];
};
type GraphQLResourceTypeMappingResponse = {
    resourceTypes: GraphQLResourceTypeMapping[];
};
type GraphQLResourceTypeMapping = {
    graphQLQueryField: string;
    graphQLQueryArguments: Record<string, string>;
    resourceTypeId: string;
    graphQLOutputType?: string;
};
type GraphQLQueryRequest = {
    type: FunctionTypeEnum.GraphqlQuery;
    query: string;
    isIntrospectionQuery: boolean;
    variables: Record<string, unknown>;
    operationName?: string;
};
/**
 * @see https://spec.graphql.org/October2021/#sec-Response
 */
type GraphQLQueryResponse = {
    data?: Record<string, any> | null;
    errors?: readonly Record<string, any>[];
    extensions?: Record<string, unknown>;
};
type AppEventEntityName = keyof AppEventPayloadMap;
type AppEventEntityActions<T extends AppEventEntityName> = keyof AppEventPayloadMap[T] & string;
type AppEventEntityPayload<T extends AppEventEntityName, A extends AppEventEntityActions<T>> = AppEventPayloadMap[T][A];
type AppEventBase<EntityName extends AppEventEntityName, EntityAction extends AppEventEntityActions<EntityName>> = {
    headers: Record<string, string | number> & {
        'X-Contentful-Topic': `ContentManagement.${EntityName}.${EntityAction}`;
    };
    body: AppEventEntityPayload<EntityName, EntityAction>;
    type: FunctionTypeEnum.AppEventHandler | FunctionTypeEnum.AppEventTransformation | FunctionTypeEnum.AppEventFilter;
};
type AppEventContentType = {
    [A in AppEventEntityActions<'ContentType'>]: AppEventBase<'ContentType', A>;
}[AppEventEntityActions<'ContentType'>];
type AppEventEntry = {
    [A in AppEventEntityActions<'Entry'>]: AppEventBase<'Entry', A>;
}[AppEventEntityActions<'Entry'>];
type AppEventAsset = {
    [A in AppEventEntityActions<'Asset'>]: AppEventBase<'Asset', A>;
}[AppEventEntityActions<'Asset'>];
type AppEventAppInstallation = {
    [A in AppEventEntityActions<'AppInstallation'>]: AppEventBase<'AppInstallation', A>;
}[AppEventEntityActions<'AppInstallation'>];
type AppEventTask = {
    [A in AppEventEntityActions<'Task'>]: AppEventBase<'Task', A>;
}[AppEventEntityActions<'Task'>];
type AppEventComment = {
    [A in AppEventEntityActions<'Comment'>]: AppEventBase<'Comment', A>;
}[AppEventEntityActions<'Comment'>];
type AppEventRelease = {
    [A in AppEventEntityActions<'Release'>]: AppEventBase<'Release', A>;
}[AppEventEntityActions<'Release'>];
type AppEventReleaseAction = {
    [A in AppEventEntityActions<'ReleaseAction'>]: AppEventBase<'ReleaseAction', A>;
}[AppEventEntityActions<'ReleaseAction'>];
type AppEventScheduledAction = {
    [A in AppEventEntityActions<'ScheduledAction'>]: AppEventBase<'ScheduledAction', A>;
}[AppEventEntityActions<'ScheduledAction'>];
type AppEventBulkAction = {
    [A in AppEventEntityActions<'BulkAction'>]: AppEventBase<'BulkAction', A>;
}[AppEventEntityActions<'BulkAction'>];
type AppEventTemplateInstallation = {
    [A in AppEventEntityActions<'TemplateInstallation'>]: AppEventBase<'TemplateInstallation', A>;
}[AppEventEntityActions<'TemplateInstallation'>];
type AppEventWorkflow = {
    [A in AppEventEntityActions<'Workflow'>]: AppEventBase<'Workflow', A>;
}[AppEventEntityActions<'Workflow'>];
type AppEventRequest = {
    [T in AppEventEntityName]: {
        [A in AppEventEntityActions<T>]: AppEventBase<T, A>;
    }[AppEventEntityActions<T>];
}[AppEventEntityName];
type AppEventFilterResponse = {
    result: boolean;
};
type AppEventTransformationResponse = {
    headers: Record<string, string | number>;
    body: Record<string, unknown>;
};
type AppEventHandlerResponse = void;
/**
 * The app action request body will contain different parameters depending on the category of the app action
 *
 * Specify your app action category as the generic type `Category` to get the correct body type,
 * e.g. `const { body: { message, recipient }} = event as AppActionRequest<'Notification.v1.0'>`
 *
 * If you are using the Custom category, you can specify the parameter shape as the second generic type `CustomCategoryBody`,
 * e.g. `const { body: { myNumber }} = event as AppActionRequest<'Custom', { myNumber: number }>`
 */
type AppActionRequest<CategoryType extends AppActionCategoryType = 'Custom', CustomCategoryBody = AppActionCategoryBodyMap['Custom']> = {
    headers: Record<string, string | number>;
    body: CategoryType extends 'Custom' ? CustomCategoryBody : AppActionRequestBody<CategoryType>;
    type: FunctionTypeEnum.AppActionCall;
};
type AppActionResponse = void | Record<string, unknown>;
/**
 * P: Possibility to type app installation parameters
 */
type FunctionEventContext<P extends Record<string, any> = Record<string, any>> = {
    spaceId: string;
    environmentId: string;
    appInstallationParameters: P;
    cmaClientOptions?: ClientOptions;
    cma?: PlainClientAPI;
};
/**
 * T: Possibility to type app action category
 * U: Possibility to type app action body (only applies to the Custom category)
 */
type FunctionEventHandlers<T extends AppActionCategoryType = never, U extends AppActionRequestBody<T> = never> = {
    [FunctionTypeEnum.GraphqlFieldMapping]: {
        event: GraphQLFieldTypeMappingRequest;
        response: GraphQLFieldTypeMappingResponse;
    };
    [FunctionTypeEnum.GraphqlResourceTypeMapping]: {
        event: GraphQLResourceTypeMappingRequest;
        response: GraphQLResourceTypeMappingResponse;
    };
    [FunctionTypeEnum.GraphqlQuery]: {
        event: GraphQLQueryRequest;
        response: GraphQLQueryResponse;
    };
    [FunctionTypeEnum.AppActionCall]: {
        event: AppActionRequest<T, U>;
        response: AppActionResponse;
    };
    [FunctionTypeEnum.AppEventFilter]: {
        event: AppEventRequest;
        response: AppEventFilterResponse;
    };
    [FunctionTypeEnum.AppEventHandler]: {
        event: AppEventRequest;
        response: AppEventHandlerResponse;
    };
    [FunctionTypeEnum.AppEventTransformation]: {
        event: AppEventRequest;
        response: AppEventTransformationResponse;
    };
    [FunctionTypeEnum.ResourcesSearch]: {
        event: ResourcesSearchRequest;
        response: ResourcesSearchResponse;
    };
    [FunctionTypeEnum.ResourcesLookup]: {
        event: ResourcesLookupRequest;
        response: ResourcesLookupResponse;
    };
};
type FunctionEvent = GraphQLFieldTypeMappingRequest | GraphQLResourceTypeMappingRequest | GraphQLQueryRequest | AppActionRequest | AppEventRequest | ResourcesSearchRequest | ResourcesLookupRequest;
type FunctionEventType = keyof FunctionEventHandlers;
/**
 * Event handler type that needs to be exported as `handler` from your function.
 * e.g. `const handler: FunctionEventHandler = (event, context) => { ... }`
 *
 * This type can also be used to construct helper functions for specific events
 * e.g. `const queryHandler: FunctionEventHandler<'graphql.query'> = (event, context) => { ... }`
 */
type FunctionEventHandler<K extends FunctionEventType = FunctionEventType, P extends Record<string, any> = Record<string, any>> = (event: FunctionEventHandlers[K]['event'], context: FunctionEventContext<P>) => Promise<FunctionEventHandlers[K]['response']> | FunctionEventHandlers[K]['response'];

declare const CanonicalRequestValidator: runtypes.Intersect2<runtypes.Record<{
    method: runtypes.Union7<runtypes.Literal<"GET">, runtypes.Literal<"PATCH">, runtypes.Literal<"HEAD">, runtypes.Literal<"POST">, runtypes.Literal<"DELETE">, runtypes.Literal<"OPTIONS">, runtypes.Literal<"PUT">>;
    path: runtypes.Constraint<runtypes.String, string, unknown>;
}, false>, runtypes.Partial<{
    headers: runtypes.StringDictionary<runtypes.String>;
    body: runtypes.String;
}, false>>;
type CanonicalRequest = runtypes.Static<typeof CanonicalRequestValidator>;
declare const SecretValidator: runtypes.Constraint<runtypes.String, string, unknown>;
type Secret = runtypes.Static<typeof SecretValidator>;
declare const TimestampValidator: runtypes.Constraint<runtypes.Number, number, unknown>;
type Timestamp = runtypes.Static<typeof TimestampValidator>;
declare const RequestMetadataValidator: runtypes.Record<{
    signature: runtypes.Constraint<runtypes.String, string, unknown>;
    timestamp: runtypes.Constraint<runtypes.Number, number, unknown>;
    signedHeaders: runtypes.Constraint<runtypes.Array<runtypes.String, false>, string[], unknown>;
}, false>;
type RequestMetadata = runtypes.Static<typeof RequestMetadataValidator>;
declare const TimeToLiveValidator: runtypes.Constraint<runtypes.Number, number, unknown>;
type TimeToLive = runtypes.Static<typeof TimeToLiveValidator>;

declare enum ContentfulHeader {
    Timestamp = "x-contentful-timestamp",
    SignedHeaders = "x-contentful-signed-headers",
    Signature = "x-contentful-signature"
}
declare enum ContentfulContextHeader {
    CRN = "x-contentful-crn",
    SpaceId = "x-contentful-space-id",
    EnvironmentId = "x-contentful-environment-id",
    UserId = "x-contentful-user-id",
    AppId = "x-contentful-app-id"
}
type NormalizedCanonicalRequest = {
    method: CanonicalRequest['method'];
    path: CanonicalRequest['path'];
    headers: [key: string, value: string][];
    body: CanonicalRequest['body'];
};
type SubjectHeadersApp = {
    appId: string;
};
type AppContextSignedHeaders = {
    [ContentfulContextHeader.AppId]: string;
};
type SubjectHeadersUser = {
    userId: string;
};
type UserContextSignedHeaders = {
    [ContentfulContextHeader.UserId]: string;
};
type Context<SubjectContext> = {
    crn?: string;
    spaceId: string;
    envId: string;
} & SubjectContext;
type SignedHeadersWithoutSubject = {
    [ContentfulContextHeader.CRN]?: string;
    [ContentfulContextHeader.SpaceId]: string;
    [ContentfulContextHeader.EnvironmentId]: string;
};
type SignedContextHeaders<SubjectSignedHeaders> = SignedHeadersWithoutSubject & SubjectSignedHeaders;
type SignedRequestWithoutContextHeaders = {
    [key in ContentfulHeader]: string;
};
type SignedRequestWithContextHeadersWithUser = SignedRequestWithoutContextHeaders & SignedContextHeaders<UserContextSignedHeaders>;
type SignedRequestWithContextHeadersWithApp = SignedRequestWithoutContextHeaders & SignedContextHeaders<AppContextSignedHeaders>;
type SignedRequestHeaders = SignedRequestWithContextHeadersWithUser | SignedRequestWithContextHeadersWithApp | SignedRequestWithoutContextHeaders;

export { type AppActionCallContext, type AppActionCategoryBodyMap, type AppActionCustomCategoryBody, type AppActionEntriesV1CategoryBody, type AppActionNotificationsV1CategoryBody, type AppActionRequest, type AppActionRequestBody, type AppActionResponse, type AppContextSignedHeaders, type AppEventAppInstallation, type AppEventAsset, type AppEventBulkAction, type AppEventComment, type AppEventContentType, type AppEventEntry, type AppEventFilterResponse, type AppEventHandlerResponse, type AppEventPayloadMap, type AppEventRelease, type AppEventReleaseAction, type AppEventRequest, type AppEventScheduledAction, type AppEventTask, type AppEventTemplateInstallation, type AppEventTransformationResponse, type AppEventWorkflow, type AssetArchiveEventPayload, type AssetAutosaveEventPayload, type AssetCreateEventPayload, type AssetDeleteEventPayload, type AssetPublishEventPayload, type AssetSaveEventPayload, type AssetUnarchiveEventPayload, type AssetUnpublishEventPayload, type CanonicalRequest, CanonicalRequestValidator, type ContentTypeCreateEventPayload, type ContentTypeDeleteEventPayload, type ContentTypePublishEventPayload, type ContentTypeSaveEventPayload, type ContentTypeUnpublishEventPayload, ContentfulContextHeader, ContentfulHeader, type Context, type CreateCommentEventPayload, type CreateTaskEventPayload, type DeleteCommentEventPayload, type DeleteTaskEventPayload, type EntryArchiveEventPayload, type EntryAutosaveEventPayload, type EntryCreateEventPayload, type EntryDeleteEventPayload, type EntryPublishEventPayload, type EntrySaveEventPayload, type EntryUnarchiveEventPayload, type EntryUnpublishEventPayload, type FunctionEvent, type FunctionEventContext, type FunctionEventHandler, type FunctionEventType, FunctionTypeEnum, type GraphQLFieldTypeMapping, type GraphQLFieldTypeMappingResponse, type GraphQLQueryResponse, type NormalizedCanonicalRequest, type RequestMetadata, RequestMetadataValidator, type SaveTaskEventPayload, type Secret, SecretValidator, type SignedContextHeaders, type SignedRequestHeaders, type SignedRequestWithContextHeadersWithApp, type SignedRequestWithContextHeadersWithUser, type SignedRequestWithoutContextHeaders, type SubjectHeadersApp, type SubjectHeadersUser, type TimeToLive, TimeToLiveValidator, type Timestamp, TimestampValidator, type UserContextSignedHeaders };
