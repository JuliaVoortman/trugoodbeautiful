{"version":3,"sources":["../package.json","../node_modules/tsup/assets/esm_shims.js","../src/keys/get-management-token.ts","../src/utils/http.ts","../src/utils/logger.ts","../src/requests/exceptions.ts","../src/requests/sign-request.ts","../src/requests/typings/function.ts","../src/requests/typings/request.ts","../src/requests/typings/validators.ts","../src/requests/utils.ts","../src/requests/verify-request.ts"],"sourcesContent":["{\n  \"name\": \"@contentful/node-apps-toolkit\",\n  \"version\": \"3.13.1\",\n  \"description\": \"A collection of helpers and utilities for creating NodeJS Contentful Apps\",\n  \"main\": \"lib/index.cjs\",\n  \"module\": \"lib/index.mjs\",\n  \"types\": \"lib/index.d.ts\",\n  \"files\": [\n    \"lib/**/*\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"import\": \"./lib/index.mjs\",\n      \"require\": \"./lib/index.cjs\"\n    },\n    \"./keys\": {\n      \"import\": \"./lib/keys/index.mjs\",\n      \"require\": \"./lib/keys/index.cjs\"\n    },\n    \"./requests\": {\n      \"import\": \"./lib/requests/index.mjs\",\n      \"require\": \"./lib/requests/index.cjs\"\n    },\n    \"./requests/typings\": {\n      \"import\": \"./lib/requests//typingsindex.mjs\",\n      \"require\": \"./lib/requests/typings/index.cjs\"\n    },\n    \"./utils\": {\n      \"import\": \"./lib/utils/index.mjs\",\n      \"require\": \"./lib/utils/index.cjs\"\n    }\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"scripts\": {\n    \"prepare\": \"husky install\",\n    \"lint\": \"eslint --ext .ts ./src\",\n    \"lint:fix\": \"npm run lint -- --fix\",\n    \"pretest\": \"echo ' ðŸ”‘ Creating valid keypair for testing' && sh test/make-private-keys.sh &> /dev/null\",\n    \"test:unit\": \"mocha -r dotenv/config -r ts-node/register ./src/**/*.spec.ts\",\n    \"test:integration\": \"mocha -r dotenv/config -r ts-node/register --timeout 10000 ./test/**/*.test.ts\",\n    \"test\": \"npm run test:unit && npm run test:integration\",\n    \"build\": \"rm -rf lib && tsup\",\n    \"postbuild\": \"cp ./lib/index.d.ts ./lib/index.d.cts\",\n    \"build:docs\": \"typedoc --options .typedocrc.json src\",\n    \"start:docs\": \"serve ./docs\",\n    \"prepublishOnly\": \"npm run build && npm run build:docs\",\n    \"semantic-release\": \"semantic-release\",\n    \"format\": \"prettier --write ./{src,test}/**/*.ts\"\n  },\n  \"author\": \"Contentful GmbH\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@types/debug\": \"^4.1.5\",\n    \"contentful-management\": \"^11.6.1\",\n    \"debug\": \"^4.2.0\",\n    \"got\": \"^11.7.0\",\n    \"jsonwebtoken\": \"^9.0.0\",\n    \"lru-cache\": \"^10.4.3\",\n    \"runtypes\": \"^5.0.1\"\n  },\n  \"devDependencies\": {\n    \"@semantic-release/changelog\": \"6.0.3\",\n    \"@semantic-release/git\": \"10.0.1\",\n    \"@types/jsonwebtoken\": \"9.0.6\",\n    \"@types/mocha\": \"10.0.6\",\n    \"@types/node\": \"22.5.4\",\n    \"@types/sinon\": \"17.0.3\",\n    \"@typescript-eslint/eslint-plugin\": \"7.10.0\",\n    \"@typescript-eslint/parser\": \"7.10.0\",\n    \"base64url\": \"3.0.1\",\n    \"dotenv\": \"16.4.5\",\n    \"eslint\": \"8.57.0\",\n    \"eslint-config-prettier\": \"9.1.0\",\n    \"eslint-plugin-prettier\": \"^5.0.0\",\n    \"husky\": \"9.0.11\",\n    \"lint-staged\": \"15.2.10\",\n    \"mocha\": \"10.4.0\",\n    \"prettier\": \"3.2.5\",\n    \"semantic-release\": \"23.1.1\",\n    \"serve\": \"14.2.4\",\n    \"sinon\": \"18.0.0\",\n    \"ts-node\": \"10.9.2\",\n    \"tsup\": \"^8.3.5\",\n    \"typedoc\": \"0.25.13\",\n    \"typescript\": \"5.4.5\"\n  },\n  \"lint-staged\": {\n    \"*.ts\": [\n      \"npm run lint:fix\",\n      \"npm run format\"\n    ]\n  },\n  \"repository\": {\n    \"url\": \"github:contentful/node-apps-toolkit\",\n    \"type\": \"git\"\n  }\n}\n","// Shim globals in esm bundle\nimport { fileURLToPath } from 'url'\nimport path from 'path'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","import * as jwtImpl from 'jsonwebtoken'\nimport type { SignOptions } from 'jsonwebtoken'\nimport { LRUCache } from 'lru-cache'\nimport {\n  createLogger,\n  Logger,\n  createHttpClient,\n  createValidateStatusCode,\n  HttpClient,\n} from '../utils'\n\nconst jwt = 'default' in jwtImpl ? jwtImpl.default : jwtImpl\nconst { sign, decode } = jwt as typeof jwtImpl\nexport interface GetManagementTokenOptions {\n  appInstallationId: string\n  spaceId: string\n  environmentId: string\n  keyId?: string\n  reuseToken?: boolean\n  host?: string\n}\n\nlet defaultCache: LRUCache<string, string> | undefined\n\n/**\n * Synchronously sign the given privateKey into a JSON Web Token string\n * @internal\n */\nconst generateOneTimeToken = (\n  privateKey: string,\n  { appId, keyId }: { appId: string; keyId?: string },\n  { log }: { log: Logger },\n): string => {\n  log('Signing a JWT token with private key')\n  try {\n    const baseSignOptions: SignOptions = { algorithm: 'RS256', issuer: appId, expiresIn: '10m' }\n    const signOptions: SignOptions = keyId ? { ...baseSignOptions, keyid: keyId } : baseSignOptions\n\n    const token = sign({}, privateKey, signOptions)\n    log('Successfully signed token')\n    return token\n  } catch (e) {\n    log('Unable to sign token')\n    throw e\n  }\n}\n\nconst getTokenFromOneTimeToken = async (\n  appToken: string,\n  {\n    appInstallationId,\n    spaceId,\n    environmentId,\n  }: { appInstallationId: string; spaceId: string; environmentId: string },\n  { log, http }: { log: Logger; http: HttpClient },\n): Promise<string> => {\n  const validateStatusCode = createValidateStatusCode([201])\n\n  log(`Requesting CMA Token with given App Token`)\n\n  const response = await http.post(\n    `spaces/${spaceId}/environments/${environmentId}/app_installations/${appInstallationId}/access_tokens`,\n    {\n      headers: {\n        Authorization: `Bearer ${appToken}`,\n      },\n      hooks: {\n        afterResponse: [validateStatusCode],\n      },\n    },\n  )\n\n  log(\n    `Successfully retrieved CMA Token for app ${appInstallationId} in space ${spaceId} and environment ${environmentId}`,\n  )\n\n  return JSON.parse(response.body).token\n}\n\n/**\n * Factory method for GetManagementToken\n * @internal\n */\nexport const createGetManagementToken = (\n  log: Logger,\n  http: HttpClient,\n  cache: LRUCache<string, string>,\n) => {\n  return async (privateKey: unknown, opts: GetManagementTokenOptions): Promise<string> => {\n    if (!(typeof privateKey === 'string')) {\n      throw new ReferenceError('Invalid privateKey: expected a string representing a private key')\n    }\n\n    if (opts.reuseToken === undefined) {\n      opts.reuseToken = true\n    }\n\n    const cacheKey =\n      opts.appInstallationId + opts.spaceId + opts.environmentId + privateKey.slice(32, 132)\n    if (opts.reuseToken) {\n      const existing = cache.get(cacheKey) as string\n      if (existing) {\n        return existing as string\n      }\n    }\n\n    const appToken = generateOneTimeToken(\n      privateKey,\n      { appId: opts.appInstallationId, keyId: opts.keyId },\n      { log },\n    )\n    const ott = await getTokenFromOneTimeToken(appToken, opts, { log, http })\n    if (opts.reuseToken) {\n      const decoded = decode(ott)\n      if (decoded && typeof decoded === 'object' && decoded.exp) {\n        // Internally expire cached tokens a bit earlier to make sure token isn't expired on arrival\n        const safetyMargin = 10\n        const ttlSeconds = decoded.exp - Math.floor(Date.now() / 1000) - safetyMargin\n        cache.set(cacheKey, ott, { ttl: ttlSeconds })\n      }\n    }\n\n    return ott\n  }\n}\n\n/**\n * Returns a Contentful Management API token from private key\n * Management tokens are cached internally until until they expire.\n * Pass `reuseToken: false` in the options for `getManagementToken` to disable this feature.\n *\n * NodeJS Contentful Apps need a management token to interact with Contentful's APIs.\n * Creating a management token requires a key pair to be registered for the app, follow\n * [this link](http://contentful./developers/docs/references/content-management-api/#/reference/app-keys/app-keys)\n * for more information on key pairs.\n *\n * Once a key pair is registered the getManagementToken function can be used to generate a valid token.\n *\n * ~~~\n * const {getManagementToken} = require('contentful-node-apps-toolkit')\n *\n * getManagementToken(PRIVATE_KEY, {appInstallationId, spaceId, environmentId})\n *    .then( (token) => {\n *      console.log('Here is your token')\n *      console.log(token)\n *    })\n * ~~~\n * @category Keys\n */\nexport const getManagementToken = (privateKey: string, opts: GetManagementTokenOptions) => {\n  if ((opts.reuseToken || opts.reuseToken === undefined) && !defaultCache) {\n    defaultCache = new LRUCache({ max: 10 })\n  }\n  const httpClientOpts = typeof opts.host !== 'undefined' ? { prefixUrl: opts.host } : {}\n\n  return createGetManagementToken(\n    createLogger({ filename: __filename }),\n    createHttpClient(httpClientOpts),\n    defaultCache!,\n  )(privateKey, opts)\n}\n","import got, { ExtendOptions, Got, HTTPError, Response as GotResponse } from 'got'\n\nconst config = {\n  prefixUrl: process.env.BASE_URL || 'https://api.contentful.com',\n  retry: { limit: 3 },\n}\n\nexport const createHttpClient = (configOverride: ExtendOptions = {}) => {\n  return got.extend({ ...config, ...configOverride })\n}\n\nexport const createValidateStatusCode = (allowedStatusCodes: number[]) => (response: Response) => {\n  if (!allowedStatusCodes.includes(response.statusCode)) {\n    console.log(response.body)\n    throw new HTTPError(response)\n  }\n  return response\n}\n\nexport { HTTPError as HttpError }\n\nexport type HttpClient = Got\nexport type Response = GotResponse\n","import * as path from 'path'\nimport debug from 'debug'\n\nconst SRC_PATH = path.join(__dirname, '..')\nconst { name: APP_NAME } = require('../../package.json')\n\nconst getNamespaceFromFilename = (filename: string) => {\n  return filename.split(SRC_PATH)[1].slice(0, -3)\n}\n\n/**\n * @internal\n */\nexport const createLogger = (opts: { namespace: string } | { filename: string }) => {\n  const ns = 'namespace' in opts ? opts.namespace : getNamespaceFromFilename(opts.filename)\n\n  return debug(APP_NAME).extend(ns)\n}\n\nexport type Logger = debug.Debugger\n","export class ExpiredRequestException extends Error {\n  private readonly ttl: number\n\n  constructor(ttl: number) {\n    super()\n\n    this.ttl = ttl\n    this.message = `[${this.constructor.name}]: Requests are expected to be verified within ${this.ttl}s from their signature.`\n  }\n}\n","import * as crypto from 'crypto'\nimport {\n  CanonicalRequest,\n  NormalizedCanonicalRequest,\n  Secret,\n  Timestamp,\n  ContentfulHeader,\n  Context,\n  SignedRequestWithoutContextHeaders,\n  SubjectHeadersApp,\n  SubjectHeadersUser,\n  SignedRequestWithContextHeadersWithApp,\n  SignedRequestWithContextHeadersWithUser,\n} from './typings'\nimport { CanonicalRequestValidator, SecretValidator, TimestampValidator } from './typings'\nimport {\n  getNormalizedEncodedURI,\n  normalizeHeaders,\n  sortHeaderKeys,\n  normalizeContextHeaders,\n} from './utils'\n\nconst hash = (normalizedCanonicalRequest: NormalizedCanonicalRequest, secret: string) => {\n  const stringifiedHeaders = normalizedCanonicalRequest\n    .headers!.map(([key, value]) => `${key}:${value}`)\n    .join(';')\n\n  const stringifiedRequest = [\n    normalizedCanonicalRequest.method,\n    normalizedCanonicalRequest.path,\n    stringifiedHeaders,\n    normalizedCanonicalRequest.body,\n  ].join('\\n')\n\n  const hmac = crypto.createHmac('sha256', secret)\n\n  hmac.update(stringifiedRequest)\n\n  return hmac.digest('hex')\n}\n\nconst getSortedAndSignedHeaders = (headers: Record<string, string>, timestamp: number) => {\n  const rawSignedHeaders = Object.keys(headers)\n\n  if (!(ContentfulHeader.SignedHeaders in headers)) {\n    rawSignedHeaders.push(ContentfulHeader.SignedHeaders)\n  }\n\n  if (!(ContentfulHeader.Timestamp in headers)) {\n    rawSignedHeaders.push(ContentfulHeader.Timestamp)\n  }\n\n  const signedHeaders = rawSignedHeaders.sort(sortHeaderKeys).join(',')\n\n  headers[ContentfulHeader.Timestamp] = timestamp.toString()\n  headers[ContentfulHeader.SignedHeaders] = signedHeaders\n\n  const sortedHeaders = Object.entries(headers).sort(([keyA], [keyB]) => sortHeaderKeys(keyA, keyB))\n\n  return { sortedHeaders, signedHeaders }\n}\n\n/**\n * Given a secret, a canonical request, a timestamp and context headers, generates a signature.\n * ~~~\n * @category Requests\n */\n// Remove when this eslint rule covers all the cases\n// https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/ROADMAP.md\n/*eslint-disable no-unused-vars, no-redeclare*/\nexport function signRequest(\n  rawSecret: Secret,\n  rawCanonicalRequest: CanonicalRequest,\n  rawTimestamp?: Timestamp,\n): SignedRequestWithoutContextHeaders\nexport function signRequest(\n  rawSecret: Secret,\n  rawCanonicalRequest: CanonicalRequest,\n  rawTimestamp?: Timestamp,\n  rawContext?: Context<SubjectHeadersApp>,\n): SignedRequestWithContextHeadersWithApp\nexport function signRequest(\n  rawSecret: Secret,\n  rawCanonicalRequest: CanonicalRequest,\n  rawTimestamp?: Timestamp,\n  rawContext?: Context<SubjectHeadersUser>,\n): SignedRequestWithContextHeadersWithUser\nexport function signRequest(\n  rawSecret: Secret,\n  rawCanonicalRequest: CanonicalRequest,\n  rawTimestamp?: Timestamp,\n  rawContext?: any,\n) {\n  const maybeDefaultTimestamp = rawTimestamp ?? Date.now()\n  const canonicalRequest: CanonicalRequest = CanonicalRequestValidator.check(rawCanonicalRequest)\n  const timestamp: Timestamp = TimestampValidator.check(maybeDefaultTimestamp)\n  const secret: Secret = SecretValidator.check(rawSecret)\n\n  const path = getNormalizedEncodedURI(canonicalRequest.path)\n  const method = canonicalRequest.method\n  const headers = canonicalRequest.headers ? normalizeHeaders(canonicalRequest.headers) : {}\n  const body = canonicalRequest.body ?? ''\n\n  const contextHeaders = rawContext ? normalizeContextHeaders(rawContext) : {}\n\n  const { sortedHeaders, signedHeaders } = getSortedAndSignedHeaders(\n    { ...headers, ...contextHeaders },\n    timestamp,\n  )\n\n  return {\n    [ContentfulHeader.Signature]: hash({ method, headers: sortedHeaders, path, body }, secret),\n    [ContentfulHeader.SignedHeaders]: signedHeaders,\n    [ContentfulHeader.Timestamp]: timestamp.toString(),\n    ...contextHeaders,\n  }\n}\n/*eslint-enable no-unused-vars,no-redeclare */\n","// Remove when this eslint rule covers all the cases\n// https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/ROADMAP.md\n/*eslint-disable no-unused-vars*/\n\nimport { AppActionCategoryType, ClientOptions, PlainClientAPI } from 'contentful-management'\nimport { AppActionCategoryBodyMap, AppActionRequestBody } from './appAction'\nimport { AppEventPayloadMap } from './event-payloads'\nimport {\n  type ResourcesLookupRequest,\n  type ResourcesLookupResponse,\n  type ResourcesSearchRequest,\n  type ResourcesSearchResponse,\n} from './resources'\n\nexport enum FunctionTypeEnum {\n  GraphqlFieldMapping = 'graphql.field.mapping',\n  GraphqlResourceTypeMapping = 'graphql.resourcetype.mapping',\n  GraphqlQuery = 'graphql.query',\n  AppEventFilter = 'appevent.filter',\n  AppEventHandler = 'appevent.handler',\n  AppEventTransformation = 'appevent.transformation',\n  AppActionCall = 'appaction.call',\n  ResourcesSearch = 'resources.search',\n  ResourcesLookup = 'resources.lookup',\n}\n\ntype GraphQLFieldTypeMappingRequest = {\n  type: FunctionTypeEnum.GraphqlFieldMapping\n  fields: { contentTypeId: string; field: Field }[]\n}\n\ntype Field = {\n  id: string\n  type: string\n}\n\nexport type GraphQLFieldTypeMappingResponse = {\n  namespace: string\n  fields: GraphQLFieldTypeMapping[]\n}\n\nexport type GraphQLFieldTypeMapping = {\n  contentTypeId: string\n  fieldId: string\n  graphQLOutputType?: string\n  graphQLQueryField: string\n  graphQLQueryArguments: Record<string, string>\n}\n\ntype GraphQLResourceTypeMappingRequest = {\n  type: FunctionTypeEnum.GraphqlResourceTypeMapping\n  resourceTypes: {\n    resourceTypeId: string\n  }[]\n}\n\ntype GraphQLResourceTypeMappingResponse = {\n  resourceTypes: GraphQLResourceTypeMapping[]\n}\n\ntype GraphQLResourceTypeMapping = {\n  graphQLQueryField: string\n  graphQLQueryArguments: Record<string, string>\n  resourceTypeId: string\n  graphQLOutputType?: string\n}\n\ntype GraphQLQueryRequest = {\n  type: FunctionTypeEnum.GraphqlQuery\n  query: string\n  isIntrospectionQuery: boolean\n  variables: Record<string, unknown>\n  operationName?: string\n}\n\n/**\n * @see https://spec.graphql.org/October2021/#sec-Response\n */\nexport type GraphQLQueryResponse = {\n  data?: Record<string, any> | null\n  errors?: readonly Record<string, any>[]\n  extensions?: Record<string, unknown>\n}\n\ntype AppEventEntityName = keyof AppEventPayloadMap\ntype AppEventEntityActions<T extends AppEventEntityName> = keyof AppEventPayloadMap[T] & string\ntype AppEventEntityPayload<\n  T extends AppEventEntityName,\n  A extends AppEventEntityActions<T>,\n> = AppEventPayloadMap[T][A]\n\ntype AppEventBase<\n  EntityName extends AppEventEntityName,\n  EntityAction extends AppEventEntityActions<EntityName>,\n> = {\n  headers: Record<string, string | number> & {\n    'X-Contentful-Topic': `ContentManagement.${EntityName}.${EntityAction}`\n  }\n  body: AppEventEntityPayload<EntityName, EntityAction>\n  type:\n    | FunctionTypeEnum.AppEventHandler\n    | FunctionTypeEnum.AppEventTransformation\n    | FunctionTypeEnum.AppEventFilter\n}\n\nexport type AppEventContentType = {\n  [A in AppEventEntityActions<'ContentType'>]: AppEventBase<'ContentType', A>\n}[AppEventEntityActions<'ContentType'>]\n\nexport type AppEventEntry = {\n  [A in AppEventEntityActions<'Entry'>]: AppEventBase<'Entry', A>\n}[AppEventEntityActions<'Entry'>]\n\nexport type AppEventAsset = {\n  [A in AppEventEntityActions<'Asset'>]: AppEventBase<'Asset', A>\n}[AppEventEntityActions<'Asset'>]\n\nexport type AppEventAppInstallation = {\n  [A in AppEventEntityActions<'AppInstallation'>]: AppEventBase<'AppInstallation', A>\n}[AppEventEntityActions<'AppInstallation'>]\n\nexport type AppEventTask = {\n  [A in AppEventEntityActions<'Task'>]: AppEventBase<'Task', A>\n}[AppEventEntityActions<'Task'>]\n\nexport type AppEventComment = {\n  [A in AppEventEntityActions<'Comment'>]: AppEventBase<'Comment', A>\n}[AppEventEntityActions<'Comment'>]\n\nexport type AppEventRelease = {\n  [A in AppEventEntityActions<'Release'>]: AppEventBase<'Release', A>\n}[AppEventEntityActions<'Release'>]\n\nexport type AppEventReleaseAction = {\n  [A in AppEventEntityActions<'ReleaseAction'>]: AppEventBase<'ReleaseAction', A>\n}[AppEventEntityActions<'ReleaseAction'>]\n\nexport type AppEventScheduledAction = {\n  [A in AppEventEntityActions<'ScheduledAction'>]: AppEventBase<'ScheduledAction', A>\n}[AppEventEntityActions<'ScheduledAction'>]\n\nexport type AppEventBulkAction = {\n  [A in AppEventEntityActions<'BulkAction'>]: AppEventBase<'BulkAction', A>\n}[AppEventEntityActions<'BulkAction'>]\n\nexport type AppEventTemplateInstallation = {\n  [A in AppEventEntityActions<'TemplateInstallation'>]: AppEventBase<'TemplateInstallation', A>\n}[AppEventEntityActions<'TemplateInstallation'>]\n\nexport type AppEventWorkflow = {\n  [A in AppEventEntityActions<'Workflow'>]: AppEventBase<'Workflow', A>\n}[AppEventEntityActions<'Workflow'>]\n\nexport type AppEventRequest = {\n  [T in AppEventEntityName]: {\n    [A in AppEventEntityActions<T>]: AppEventBase<T, A>\n  }[AppEventEntityActions<T>]\n}[AppEventEntityName]\n\nexport type AppEventFilterResponse = {\n  result: boolean\n}\n\nexport type AppEventTransformationResponse = {\n  headers: Record<string, string | number>\n  body: Record<string, unknown>\n}\n\nexport type AppEventHandlerResponse = void\n\n/**\n * The app action request body will contain different parameters depending on the category of the app action\n *\n * Specify your app action category as the generic type `Category` to get the correct body type,\n * e.g. `const { body: { message, recipient }} = event as AppActionRequest<'Notification.v1.0'>`\n *\n * If you are using the Custom category, you can specify the parameter shape as the second generic type `CustomCategoryBody`,\n * e.g. `const { body: { myNumber }} = event as AppActionRequest<'Custom', { myNumber: number }>`\n */\nexport type AppActionRequest<\n  CategoryType extends AppActionCategoryType = 'Custom',\n  CustomCategoryBody = AppActionCategoryBodyMap['Custom'],\n> = {\n  headers: Record<string, string | number>\n  body: CategoryType extends 'Custom' ? CustomCategoryBody : AppActionRequestBody<CategoryType>\n  type: FunctionTypeEnum.AppActionCall\n}\n\nexport type AppActionResponse = void | Record<string, unknown>\n\n/**\n * P: Possibility to type app installation parameters\n */\nexport type FunctionEventContext<P extends Record<string, any> = Record<string, any>> = {\n  spaceId: string\n  environmentId: string\n  appInstallationParameters: P\n  cmaClientOptions?: ClientOptions\n  cma?: PlainClientAPI\n}\n\n/**\n * T: Possibility to type app action category\n * U: Possibility to type app action body (only applies to the Custom category)\n */\ntype FunctionEventHandlers<\n  T extends AppActionCategoryType = never,\n  U extends AppActionRequestBody<T> = never,\n> = {\n  [FunctionTypeEnum.GraphqlFieldMapping]: {\n    event: GraphQLFieldTypeMappingRequest\n    response: GraphQLFieldTypeMappingResponse\n  }\n  [FunctionTypeEnum.GraphqlResourceTypeMapping]: {\n    event: GraphQLResourceTypeMappingRequest\n    response: GraphQLResourceTypeMappingResponse\n  }\n  [FunctionTypeEnum.GraphqlQuery]: {\n    event: GraphQLQueryRequest\n    response: GraphQLQueryResponse\n  }\n  [FunctionTypeEnum.AppActionCall]: {\n    event: AppActionRequest<T, U>\n    response: AppActionResponse\n  }\n  [FunctionTypeEnum.AppEventFilter]: {\n    event: AppEventRequest\n    response: AppEventFilterResponse\n  }\n  [FunctionTypeEnum.AppEventHandler]: {\n    event: AppEventRequest\n    response: AppEventHandlerResponse\n  }\n  [FunctionTypeEnum.AppEventTransformation]: {\n    event: AppEventRequest\n    response: AppEventTransformationResponse\n  }\n  [FunctionTypeEnum.ResourcesSearch]: {\n    event: ResourcesSearchRequest\n    response: ResourcesSearchResponse\n  }\n  [FunctionTypeEnum.ResourcesLookup]: {\n    event: ResourcesLookupRequest\n    response: ResourcesLookupResponse\n  }\n}\n\nexport type FunctionEvent =\n  | GraphQLFieldTypeMappingRequest\n  | GraphQLResourceTypeMappingRequest\n  | GraphQLQueryRequest\n  | AppActionRequest\n  | AppEventRequest\n  | ResourcesSearchRequest\n  | ResourcesLookupRequest\nexport type FunctionEventType = keyof FunctionEventHandlers\n\n/**\n * Event handler type that needs to be exported as `handler` from your function.\n * e.g. `const handler: FunctionEventHandler = (event, context) => { ... }`\n *\n * This type can also be used to construct helper functions for specific events\n * e.g. `const queryHandler: FunctionEventHandler<'graphql.query'> = (event, context) => { ... }`\n */\nexport type FunctionEventHandler<\n  K extends FunctionEventType = FunctionEventType,\n  P extends Record<string, any> = Record<string, any>,\n> = (\n  event: FunctionEventHandlers[K]['event'],\n  context: FunctionEventContext<P>,\n) => Promise<FunctionEventHandlers[K]['response']> | FunctionEventHandlers[K]['response']\n","// Remove when this eslint rule covers all the cases\n// https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/ROADMAP.md\n/*eslint-disable no-unused-vars*/\nimport { CanonicalRequest } from './validators'\n\nexport enum ContentfulHeader {\n  Timestamp = 'x-contentful-timestamp',\n  SignedHeaders = 'x-contentful-signed-headers',\n  Signature = 'x-contentful-signature',\n}\n\nexport enum ContentfulContextHeader {\n  CRN = 'x-contentful-crn',\n  SpaceId = 'x-contentful-space-id',\n  EnvironmentId = 'x-contentful-environment-id',\n  UserId = 'x-contentful-user-id',\n  AppId = 'x-contentful-app-id',\n}\n\nexport type NormalizedCanonicalRequest = {\n  method: CanonicalRequest['method']\n  path: CanonicalRequest['path']\n  headers: [key: string, value: string][]\n  body: CanonicalRequest['body']\n}\n\nexport type SubjectHeadersApp = { appId: string }\nexport type AppContextSignedHeaders = { [ContentfulContextHeader.AppId]: string }\nexport type SubjectHeadersUser = { userId: string }\nexport type UserContextSignedHeaders = { [ContentfulContextHeader.UserId]: string }\n\nexport type Context<SubjectContext> = {\n  crn?: string\n  spaceId: string\n  envId: string\n} & SubjectContext\n\ntype SignedHeadersWithoutSubject = {\n  [ContentfulContextHeader.CRN]?: string\n  [ContentfulContextHeader.SpaceId]: string\n  [ContentfulContextHeader.EnvironmentId]: string\n}\n\nexport type SignedContextHeaders<SubjectSignedHeaders> = SignedHeadersWithoutSubject &\n  SubjectSignedHeaders\n\nexport type SignedRequestWithoutContextHeaders = {\n  [key in ContentfulHeader]: string\n}\nexport type SignedRequestWithContextHeadersWithUser = SignedRequestWithoutContextHeaders &\n  SignedContextHeaders<UserContextSignedHeaders>\nexport type SignedRequestWithContextHeadersWithApp = SignedRequestWithoutContextHeaders &\n  SignedContextHeaders<AppContextSignedHeaders>\n\nexport type SignedRequestHeaders =\n  | SignedRequestWithContextHeadersWithUser\n  | SignedRequestWithContextHeadersWithApp\n  | SignedRequestWithoutContextHeaders\n","import * as runtypes from 'runtypes'\n\nconst MethodValidator = runtypes.Union(\n  runtypes.Literal('GET'),\n  runtypes.Literal('PATCH'),\n  runtypes.Literal('HEAD'),\n  runtypes.Literal('POST'),\n  runtypes.Literal('DELETE'),\n  runtypes.Literal('OPTIONS'),\n  runtypes.Literal('PUT'),\n)\n\nconst PathValidator = runtypes.String.withConstraint((s) => s.startsWith('/'), {\n  name: 'CanonicalURI',\n})\n\nconst SignatureValidator = runtypes.String.withConstraint((s) => s.length === 64, {\n  name: 'SignatureLength',\n})\n\nexport const CanonicalRequestValidator = runtypes\n  .Record({\n    method: MethodValidator,\n    path: PathValidator,\n  })\n  .And(\n    runtypes.Partial({\n      headers: runtypes.Dictionary(runtypes.String, 'string'),\n      body: runtypes.String,\n    }),\n  )\nexport type CanonicalRequest = runtypes.Static<typeof CanonicalRequestValidator>\n\nexport const SecretValidator = runtypes.String.withConstraint((s) => s.length === 64, {\n  name: 'SecretLength',\n})\nexport type Secret = runtypes.Static<typeof SecretValidator>\n\n// Only dates after 01-01-2020\nexport const TimestampValidator = runtypes.Number.withConstraint((n) => n > 1577836800000, {\n  name: 'TimestampAge',\n})\nexport type Timestamp = runtypes.Static<typeof TimestampValidator>\n\nconst SignedHeadersValidator = runtypes\n  .Array(runtypes.String)\n  .withConstraint((l) => l.length >= 2, { name: 'MissingTimestampOrSignedHeaders' })\n\nexport const RequestMetadataValidator = runtypes.Record({\n  signature: SignatureValidator,\n  timestamp: TimestampValidator,\n  signedHeaders: SignedHeadersValidator,\n})\nexport type RequestMetadata = runtypes.Static<typeof RequestMetadataValidator>\n\nexport const TimeToLiveValidator = runtypes.Number.withConstraint((n) => n >= 0, {\n  name: 'PositiveNumber',\n})\nexport type TimeToLive = runtypes.Static<typeof TimeToLiveValidator>\n","import * as querystring from 'querystring'\nimport {\n  AppContextSignedHeaders,\n  ContentfulContextHeader,\n  Context,\n  SignedContextHeaders,\n  SubjectHeadersApp,\n  SubjectHeadersUser,\n  UserContextSignedHeaders,\n} from './typings'\n\nexport const getNormalizedEncodedURI = (uri: string) => {\n  const [pathname, search] = uri.split('?')\n  const escapedSearch = search ? querystring.escape(search) : ''\n\n  return encodeURI(escapedSearch ? `${pathname}?${escapedSearch}` : pathname)\n}\n\nexport const sortHeaderKeys = (keyA: string, keyB: string) => (keyA > keyB ? 1 : -1)\n\nconst normalizeHeaderKey = (key: string) => key.toLowerCase().trim()\nconst normalizeHeaderValue = (value: string) => value.trim()\nexport const normalizeHeaders = (headers: Record<string, string>) =>\n  map(headers, ([key, value]) => [normalizeHeaderKey(key), normalizeHeaderValue(value)])\n\nexport const pickHeaders = (headers?: Record<string, string>, keys?: string[]) => {\n  if (!headers) {\n    return {}\n  }\n\n  if (!keys) {\n    return headers\n  }\n\n  return filter(headers, ([key]) => keys.includes(key))\n}\n\nconst contextHeadersMap: Record<string, ContentfulContextHeader> = {\n  crn: ContentfulContextHeader.CRN,\n  spaceId: ContentfulContextHeader.SpaceId,\n  envId: ContentfulContextHeader.EnvironmentId,\n  appId: ContentfulContextHeader.AppId,\n  userId: ContentfulContextHeader.UserId,\n}\n\n// Remove when this eslint rule covers all the cases\n// https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/ROADMAP.md\n/*eslint-disable no-unused-vars, no-redeclare*/\nexport function normalizeContextHeaders(\n  rawContext: Context<SubjectHeadersApp>,\n): SignedContextHeaders<AppContextSignedHeaders>\nexport function normalizeContextHeaders(\n  rawContext: Context<SubjectHeadersUser>,\n): SignedContextHeaders<UserContextSignedHeaders>\nexport function normalizeContextHeaders(\n  rawContext: Context<SubjectHeadersApp> | Context<SubjectHeadersUser>,\n) {\n  return Object.keys(rawContext).reduce(\n    (acc, header) => {\n      if (contextHeadersMap[header]) {\n        const key = normalizeHeaderKey(contextHeadersMap[header]) as ContentfulContextHeader\n        acc[key] = normalizeHeaderValue(\n          acc[key] ??\n            rawContext[header as keyof (Context<SubjectHeadersUser> | Context<SubjectHeadersApp>)],\n        )\n      }\n      return acc\n    },\n    {} as Record<ContentfulContextHeader, string>,\n  )\n}\n/*eslint-enable no-unused-vars, no-redeclare*/\n\n// Remove when this eslint rule covers all the cases\n// https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/ROADMAP.md\n/*eslint-disable no-unused-vars*/\nexport const filter = <T = string>(\n  obj: Record<string, any>,\n  callback: (entry: [string, T]) => boolean,\n) => {\n  return Object.fromEntries(Object.entries(obj).filter(callback))\n}\n\nexport const map = <T = string>(\n  obj: Record<string, any>,\n  callback: (entry: [string, T]) => [string, T],\n) => {\n  return Object.fromEntries(Object.entries(obj).map(callback))\n}\n/*eslint-enable no-unused-vars*/\n","import {\n  CanonicalRequest,\n  CanonicalRequestValidator,\n  RequestMetadata,\n  RequestMetadataValidator,\n  Secret,\n  SecretValidator,\n  Timestamp,\n  TimeToLive,\n  ContentfulHeader,\n} from './typings'\nimport { normalizeHeaders, pickHeaders } from './utils'\nimport { signRequest } from './sign-request'\nimport { ExpiredRequestException } from './exceptions'\n\nconst getRequestMetadata = (normalizedHeaders: Record<string, string>): RequestMetadata => {\n  const signature = normalizedHeaders[ContentfulHeader.Signature]\n  const signedHeaders = (normalizedHeaders[ContentfulHeader.SignedHeaders] ?? '').split(',')\n  const timestamp = Number.parseInt(normalizedHeaders[ContentfulHeader.Timestamp] ?? '', 10)\n\n  return RequestMetadataValidator.check({ signature, signedHeaders, timestamp })\n}\n\nconst isRequestTimestampTooOld = (ttl: number, timestamp: Timestamp) => {\n  return Date.now() - timestamp >= ttl * 1000\n}\n\n/**\n * Given a secret verifies a CanonicalRequest. It also throws when signature is older than `rawTimeToLive` seconds.\n * Pass `rawTimeToLive = 0` to disable TTL checks.\n *\n * ~~~\n * const { verifyRequest } = require('@contentful/node-apps-toolkit')\n * const { server } = require('./imaginary-server')\n * const { makeCanonicalRequestFromImaginaryServerRequest } = require('./imaginary-utils')\n *\n * const SECRET = process.env.SECRET\n * const REQUEST_TTL = Number.parseInt(process.env.REQUEST_TTL, 10)\n *\n * server.post('/api/my-resources', (req, res) => {\n *   const canonicalRequest = makeCanonicalRequestFromImaginaryServerRequest(req)\n *\n *   try {\n *     const isVerifiedRequest = verifyRequest(SECRET, canonicalRequest, REQUEST_TTL)\n *\n *     if (!isVerifiedRequest) {\n *       res.send(403, 'Invalid signature')\n *     }\n *   } catch (_error) {\n *     res.send(422, 'Unable to verify request')\n *   }\n *\n *   // Rest of the code\n * })\n *\n * ~~~\n * @category Requests\n */\nexport const verifyRequest = (\n  rawSecret: Secret,\n  rawCanonicalRequest: CanonicalRequest,\n  rawTimeToLive: TimeToLive = 30,\n): boolean => {\n  const canonicalRequest = CanonicalRequestValidator.check(rawCanonicalRequest)\n  const secret = SecretValidator.check(rawSecret)\n\n  const normalizedHeaders = normalizeHeaders(canonicalRequest.headers ?? {})\n\n  const { signature, signedHeaders, timestamp } = getRequestMetadata(normalizedHeaders)\n\n  if (rawTimeToLive !== 0 && isRequestTimestampTooOld(rawTimeToLive, timestamp)) {\n    throw new ExpiredRequestException(rawTimeToLive)\n  }\n\n  const requestToValidate = {\n    ...canonicalRequest,\n    headers: pickHeaders(normalizedHeaders, signedHeaders),\n  }\n\n  const { [ContentfulHeader.Signature]: computedSignature } = signRequest(\n    secret,\n    requestToValidate,\n    timestamp,\n  )\n\n  return signature === computedSignature\n}\n"],"mappings":"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","names":["path","FunctionTypeEnum","ContentfulHeader","ContentfulContextHeader","path"]}