{"ast":null,"code":"var W = {\n    0: 8203,\n    1: 8204,\n    2: 8205,\n    3: 8290,\n    4: 8291,\n    5: 8288,\n    6: 65279,\n    7: 8289,\n    8: 119155,\n    9: 119156,\n    a: 119157,\n    b: 119158,\n    c: 119159,\n    d: 119160,\n    e: 119161,\n    f: 119162\n  },\n  L = {\n    0: 8203,\n    1: 8204,\n    2: 8205,\n    3: 65279\n  },\n  j = new Array(4).fill(String.fromCodePoint(L[0])).join(\"\"),\n  V = \"\\0\";\nfunction U(t) {\n  let n = JSON.stringify(t);\n  return `${j}${Array.from(n).map(o => {\n    let e = o.charCodeAt(0);\n    if (e > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${n} on character ${o} (${e})`);\n    return Array.from(e.toString(4).padStart(4, \"0\")).map(r => String.fromCodePoint(L[r])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction Z(t) {\n  return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);\n}\nfunction q(t) {\n  try {\n    new URL(t, t.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch (n) {\n    return !1;\n  }\n  return !0;\n}\nfunction G(t, n) {\n  let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"auto\";\n  return o === !0 || o === \"auto\" && (Z(t) || q(t)) ? t : `${t}${U(n)}`;\n}\nvar H = Object.fromEntries(Object.entries(L).map(t => t.reverse())),\n  F = Object.fromEntries(Object.entries(W).map(t => t.reverse())),\n  K = `${Object.values(W).map(t => `\\\\u{${t.toString(16)}}`).join(\"\")}`,\n  O = new RegExp(`[${K}]{4,}`, \"gu\");\nfunction X(t) {\n  let n = t.match(O);\n  if (n) return Y(n[0], !0)[0];\n}\nfunction Y(t) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n  let o = Array.from(t);\n  if (o.length % 2 === 0) {\n    if (o.length % 4 || !t.startsWith(j)) return ee(o, n);\n  } else throw new Error(\"Encoded data has invalid length\");\n  let e = [];\n  for (let r = o.length * 0.25; r--;) {\n    let s = o.slice(r * 4, r * 4 + 4).map(c => H[c.codePointAt(0)]).join(\"\");\n    e.unshift(String.fromCharCode(parseInt(s, 4)));\n  }\n  if (n) {\n    e.shift();\n    let r = e.indexOf(V);\n    return r === -1 && (r = e.length), [JSON.parse(e.slice(0, r).join(\"\"))];\n  }\n  return e.join(\"\").split(V).filter(Boolean).map(r => JSON.parse(r));\n}\nfunction ee(t, n) {\n  var o;\n  let e = [];\n  for (let i = t.length * 0.5; i--;) {\n    let u = `${F[t[i * 2].codePointAt(0)]}${F[t[i * 2 + 1].codePointAt(0)]}`;\n    e.unshift(String.fromCharCode(parseInt(u, 16)));\n  }\n  let r = [],\n    s = [e.join(\"\")],\n    c = 10;\n  for (; s.length;) {\n    let i = s.shift();\n    try {\n      if (r.push(JSON.parse(i)), n) return r;\n    } catch (u) {\n      if (!c--) throw u;\n      let a = +((o = u.message.match(/\\sposition\\s(\\d+)$/)) == null ? void 0 : o[1]);\n      if (!a) throw u;\n      s.unshift(i.substring(0, a), i.substring(a));\n    }\n  }\n  return r;\n}\nfunction te(t) {\n  var n;\n  return {\n    cleaned: t.replace(O, \"\"),\n    encoded: ((n = t.match(O)) == null ? void 0 : n[0]) || \"\"\n  };\n}\nfunction w(t, n) {\n  return G(t, n);\n}\nfunction ce(t) {\n  return U(t);\n}\nfunction ie(t) {\n  return X(t);\n}\nfunction ae(t) {\n  return te(t);\n}\nvar x, k;\nfunction ne() {\n  if (k) return x;\n  k = 1;\n  var t = Object.prototype.hasOwnProperty,\n    n = Object.prototype.toString;\n  return x = function (e, r, s) {\n    if (n.call(r) !== \"[object Function]\") throw new TypeError(\"iterator must be a function\");\n    var c = e.length;\n    if (c === +c) for (var i = 0; i < c; i++) r.call(s, e[i], i, e);else for (var u in e) t.call(e, u) && r.call(s, e[u], u, e);\n  }, x;\n}\nvar I, _;\nfunction re() {\n  if (_) return I;\n  _ = 1;\n  var t = ne();\n  I = n;\n  function n(o, e, r) {\n    if (arguments.length === 3) return n.set(o, e, r);\n    if (arguments.length === 2) return n.get(o, e);\n    var s = n.bind(n, o);\n    for (var c in n) n.hasOwnProperty(c) && (s[c] = n[c].bind(s, o));\n    return s;\n  }\n  return n.get = function (e, r) {\n    for (var s = Array.isArray(r) ? r : n.parse(r), c = 0; c < s.length; ++c) {\n      var i = s[c];\n      if (!(typeof e == \"object\" && i in e)) throw new Error(\"Invalid reference token: \" + i);\n      e = e[i];\n    }\n    return e;\n  }, n.set = function (e, r, s) {\n    var c = Array.isArray(r) ? r : n.parse(r),\n      i = c[0];\n    if (c.length === 0) throw Error(\"Can not set the root object\");\n    for (var u = 0; u < c.length - 1; ++u) {\n      var a = c[u];\n      typeof a != \"string\" && typeof a != \"number\" && (a = String(a)), !(a === \"__proto__\" || a === \"constructor\" || a === \"prototype\") && (a === \"-\" && Array.isArray(e) && (a = e.length), i = c[u + 1], a in e || (i.match(/^(\\d+|-)$/) ? e[a] = [] : e[a] = {}), e = e[a]);\n    }\n    return i === \"-\" && Array.isArray(e) && (i = e.length), e[i] = s, this;\n  }, n.remove = function (o, e) {\n    var r = Array.isArray(e) ? e : n.parse(e),\n      s = r[r.length - 1];\n    if (s === void 0) throw new Error('Invalid JSON pointer for remove: \"' + e + '\"');\n    var c = n.get(o, r.slice(0, -1));\n    if (Array.isArray(c)) {\n      var i = +s;\n      if (s === \"\" && isNaN(i)) throw new Error('Invalid array index: \"' + s + '\"');\n      Array.prototype.splice.call(c, i, 1);\n    } else delete c[s];\n  }, n.dict = function (e, r) {\n    var s = {};\n    return n.walk(e, function (c, i) {\n      s[i] = c;\n    }, r), s;\n  }, n.walk = function (e, r, s) {\n    var c = [];\n    s = s || function (i) {\n      var u = Object.prototype.toString.call(i);\n      return u === \"[object Object]\" || u === \"[object Array]\";\n    }, function i(u) {\n      t(u, function (a, l) {\n        c.push(String(l)), s(a) ? i(a) : r(a, n.compile(c)), c.pop();\n      });\n    }(e);\n  }, n.has = function (e, r) {\n    try {\n      n.get(e, r);\n    } catch (s) {\n      return !1;\n    }\n    return !0;\n  }, n.escape = function (e) {\n    return e.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n  }, n.unescape = function (e) {\n    return e.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n  }, n.parse = function (e) {\n    if (e === \"\") return [];\n    if (e.charAt(0) !== \"/\") throw new Error(\"Invalid JSON pointer: \" + e);\n    return e.substring(1).split(/\\//).map(n.unescape);\n  }, n.compile = function (e) {\n    return e.length === 0 ? \"\" : \"/\" + e.map(n.escape).join(\"/\");\n  }, I;\n}\nvar p = re();\nconst oe = _ref => {\n    let {\n      pointer: t,\n      mappings: n,\n      data: o,\n      hiddenStrings: e\n    } = _ref;\n    const r = n[t];\n    if (r) {\n      delete n[t];\n      const s = b(o, t);\n      for (const c of s) {\n        n[c] = r;\n        const i = p.get(o, c),\n          u = w(i, e);\n        p.set(o, c, u);\n      }\n    } else {\n      const s = b(o, t);\n      for (const c of s) {\n        const i = p.get(o, c),\n          u = w(i, e);\n        p.set(o, c, u);\n      }\n    }\n  },\n  b = function (t) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    const o = [],\n      e = p.get(t, n);\n    if (e.content) for (let r = 0; r < e.content.length; r++) e.content[r].nodeType === \"text\" ? o.push(`${n}/content/${r}/value`) : o.push(...b(t, `${n}/content/${r}`));\n    return o;\n  },\n  C = _ref2 => {\n    let {\n      entityId: t,\n      entityType: n,\n      space: o,\n      environment: e,\n      field: r,\n      locale: s,\n      editorInterface: c,\n      fieldType: i,\n      targetOrigin: u,\n      platform: a\n    } = _ref2;\n    const d = {\n      origin: \"contentful.com\",\n      href: `${`${u || \"https://app.contentful.com\"}/spaces/${o}/environments/${e}`}/${n === \"Entry\" ? \"entries\" : \"assets\"}/${t}/?focusedField=${r}&focusedLocale=${s}&source=vercel-content-link`,\n      contentful: {\n        editorInterface: c,\n        fieldType: i\n      }\n    };\n    return a === \"vercel\" && delete d.contentful, d;\n  },\n  B = t => [\"builtin\", \"sidebar-builtin\", \"editor-builtin\"].includes(t),\n  D = t => se.includes(t);\nfunction Q(t) {\n  if (typeof structuredClone == \"function\") return structuredClone(t);\n  try {\n    return JSON.parse(JSON.stringify(t));\n  } catch (n) {\n    return console.warn(\"Failed to clone data:\", t, n), t;\n  }\n}\nconst se = [\"singleLine\", \"tagEditor\", \"listInput\", \"checkbox\", \"richTextEditor\", \"multipleLine\"];\nfunction P(t, n, o, e, r, s, c) {\n  const i = c ? n[c] : n;\n  switch (t) {\n    case \"Symbol\":\n      {\n        const u = w(i, o);\n        p.set(e, r, u);\n        break;\n      }\n    case \"Text\":\n      {\n        const u = w(i, o);\n        p.set(e, r, u);\n        break;\n      }\n    case \"RichText\":\n      {\n        oe({\n          pointer: \"\",\n          mappings: s,\n          data: i,\n          hiddenStrings: o\n        });\n        break;\n      }\n    case \"Array\":\n      {\n        const u = i.map(a => typeof a == \"string\" ? w(a, o) : a);\n        p.set(e, r, u);\n        break;\n      }\n  }\n}\nconst ue = (t, n, o) => {\n    if (!t || !t.extensions || !t.extensions.contentSourceMaps) return console.error(\"GraphQL response does not contain Content Source Maps information.\", t), t;\n    const e = Q(t),\n      {\n        spaces: r,\n        environments: s,\n        editorInterfaces: c,\n        fields: i,\n        locales: u,\n        entries: a,\n        assets: l,\n        mappings: m,\n        fieldTypes: v\n      } = e.extensions.contentSourceMaps,\n      y = e;\n    for (const d in m) {\n      const {\n          source: f\n        } = m[d],\n        h = \"entry\" in f ? a[f.entry] : l[f.asset],\n        M = \"entry\" in f ? \"Entry\" : \"Asset\";\n      if (!h) return e;\n      const g = r[h.space],\n        A = s[h.environment],\n        E = h.id,\n        S = i[f.field],\n        T = u[f.locale],\n        N = c[f.editorInterface],\n        J = v[f.fieldType];\n      if (!(B(N.widgetNamespace) && !D(N.widgetId)) && p.has(y, d)) {\n        const R = p.get(y, d);\n        if (R !== null) {\n          const z = C({\n            entityId: E,\n            entityType: M,\n            space: g,\n            environment: A,\n            field: S,\n            locale: T,\n            editorInterface: N,\n            fieldType: J,\n            targetOrigin: n,\n            platform: o\n          });\n          P(J, R, z, y, d, m);\n        }\n      }\n    }\n    return e;\n  },\n  $ = (t, n, o, e, r) => {\n    if (!t.fields) return;\n    const {\n      contentSourceMaps: s\n    } = t.sys;\n    if (!s) return;\n    const {\n      mappings: c\n    } = s;\n    for (const i in c) {\n      const {\n          source: u\n        } = c[i],\n        a = t.sys.space.sys.id,\n        l = t.sys.environment.sys.id,\n        m = t.sys.id,\n        v = t.sys.type,\n        y = n[u.fieldType],\n        d = o[u.editorInterface];\n      if (B(d.widgetNamespace) && !D(d.widgetId)) continue;\n      const f = i.startsWith(\"/\") ? i : `/${i}`;\n      if (p.has(t, f)) {\n        const h = p.get(t, f);\n        if (h === null) return;\n        const g = f.split(\"/\").pop();\n        if (!g) {\n          console.error(\"Field name could not be extracted from the pointer\", f);\n          return;\n        }\n        const A = t.sys.locale;\n        if (A) {\n          const E = C({\n            entityId: m,\n            entityType: v,\n            space: a,\n            environment: l,\n            field: g,\n            locale: A,\n            editorInterface: d,\n            fieldType: y,\n            targetOrigin: e,\n            platform: r\n          });\n          P(y, h, E, t, f, c);\n        } else Object.keys(h).forEach(S => {\n          const T = C({\n            entityId: m,\n            entityType: v,\n            space: a,\n            environment: l,\n            field: g,\n            locale: S,\n            editorInterface: d,\n            fieldType: y,\n            targetOrigin: e,\n            platform: r\n          });\n          P(y, h, T, t, `${f}/${S}`, c, S);\n        });\n      }\n    }\n  },\n  fe = (t, n, o) => {\n    var r;\n    const e = Q(t);\n    if (e.sys && \"items\" in e) {\n      const s = e;\n      if (!((r = s.sys) != null && r.contentSourceMapsLookup)) return s;\n      const {\n          contentSourceMapsLookup: {\n            fieldTypes: c,\n            editorInterfaces: i\n          }\n        } = s.sys,\n        {\n          items: u,\n          includes: a\n        } = s;\n      u.forEach(l => $(l, c, i, n, o)), a && a.Entry && a.Entry.forEach(l => $(l, c, i, n, o)), a && a.Asset && a.Asset.forEach(l => $(l, c, i, n, o));\n    } else {\n      const s = e;\n      if (!s.sys.contentSourceMapsLookup) return console.error(\"Content source maps lookup data is missing\"), s;\n      $(s, s.sys.contentSourceMapsLookup.fieldTypes, s.sys.contentSourceMapsLookup.editorInterfaces, n, o);\n    }\n    return e;\n  };\nexport { se as SUPPORTED_WIDGETS, Q as clone, w as combine, C as createSourceMapMetadata, ie as decode, ce as encode, fe as encodeCPAResponse, P as encodeField, ue as encodeGraphQLResponse, oe as encodeRichTextValue, B as isBuiltinNamespace, D as isSupportedWidget, ae as splitEncoding };","map":{"version":3,"names":["W","a","b","c","d","e","f","L","j","Array","fill","String","fromCodePoint","join","V","U","t","n","JSON","stringify","from","map","o","charCodeAt","Error","toString","padStart","r","Z","Number","isNaN","test","Date","parse","q","URL","startsWith","G","arguments","length","undefined","H","Object","fromEntries","entries","reverse","F","K","values","O","RegExp","X","match","Y","ee","s","slice","codePointAt","unshift","fromCharCode","parseInt","shift","indexOf","split","filter","Boolean","i","u","push","message","substring","te","cleaned","replace","encoded","w","ce","ie","ae","prototype","hasOwnProperty","x","foreach","call","TypeError","ne","I","set","get","bind","isArray","remove","splice","dict","walk","l","compile","pop","has","escape","unescape","charAt","oe","_ref","pointer","mappings","data","hiddenStrings","p","findRichTextNodes","content","nodeType","C","_ref2","entityId","entityType","space","environment","field","locale","editorInterface","fieldType","targetOrigin","platform","origin","href","contentful","B","includes","D","se","Q","structuredClone","console","warn","P","ue","encodeGraphQLResponse","extensions","contentSourceMaps","error","spaces","environments","editorInterfaces","fields","locales","assets","m","fieldTypes","v","y","source","h","entry","asset","M","g","A","E","id","S","T","N","J","widgetNamespace","widgetId","R","z","$","applyEncoding","sys","type","keys","forEach","fe","encodeCPAResponse","contentSourceMapsLookup","items","Entry","Asset"],"sources":["/Users/julia.voortman/Documents/trugoodbeautiful/frontend/node_modules/node_modules/@vercel/stega/dist/index.mjs","/Users/julia.voortman/Documents/trugoodbeautiful/frontend/node_modules/@contentful/content-source-maps/src/encode.ts","/Users/julia.voortman/Documents/trugoodbeautiful/frontend/node_modules/node_modules/foreach/index.js","/Users/julia.voortman/Documents/trugoodbeautiful/frontend/node_modules/node_modules/json-pointer/index.js","/Users/julia.voortman/Documents/trugoodbeautiful/frontend/node_modules/@contentful/content-source-maps/src/richText.ts","/Users/julia.voortman/Documents/trugoodbeautiful/frontend/node_modules/@contentful/content-source-maps/src/utils.ts","/Users/julia.voortman/Documents/trugoodbeautiful/frontend/node_modules/@contentful/content-source-maps/src/graphql/encodeGraphQLResponse.ts","/Users/julia.voortman/Documents/trugoodbeautiful/frontend/node_modules/@contentful/content-source-maps/src/rest/encodeCPAResponse.ts"],"sourcesContent":["var s={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},c={0:8203,1:8204,2:8205,3:65279},u=new Array(4).fill(String.fromCodePoint(c[0])).join(\"\"),m=String.fromCharCode(0);function E(t){let e=JSON.stringify(t);return`${u}${Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(4).padStart(4,\"0\")).map(o=>String.fromCodePoint(c[o])).join(\"\")}).join(\"\")}`}function y(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(o=>String.fromCodePoint(s[o])).join(\"\")}).join(\"\")}function I(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:Boolean(Date.parse(t))}function T(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function C(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(I(t)||T(t))?t:`${t}${E(e)}`}var x=Object.fromEntries(Object.entries(c).map(t=>t.reverse())),g=Object.fromEntries(Object.entries(s).map(t=>t.reverse())),S=`${Object.values(s).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,f=new RegExp(`[${S}]{4,}`,\"gu\");function G(t){let e=t.match(f);if(!!e)return h(e[0],!0)[0]}function $(t){let e=t.match(f);if(!!e)return e.map(r=>h(r)).flat()}function h(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(u))return A(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=[];for(let o=r.length*.25;o--;){let p=r.slice(o*4,o*4+4).map(d=>x[d.codePointAt(0)]).join(\"\");n.unshift(String.fromCharCode(parseInt(p,4)))}if(e){n.shift();let o=n.indexOf(m);return o===-1&&(o=n.length),[JSON.parse(n.slice(0,o).join(\"\"))]}return n.join(\"\").split(m).filter(Boolean).map(o=>JSON.parse(o))}function A(t,e){var d;let r=[];for(let i=t.length*.5;i--;){let a=`${g[t[i*2].codePointAt(0)]}${g[t[i*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(a,16)))}let n=[],o=[r.join(\"\")],p=10;for(;o.length;){let i=o.shift();try{if(n.push(JSON.parse(i)),e)return n}catch(a){if(!p--)throw a;let l=+((d=a.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:d[1]);if(!l)throw a;o.unshift(i.substring(0,l),i.substring(l))}}return n}function _(t){var e;return{cleaned:t.replace(f,\"\"),encoded:((e=t.match(f))==null?void 0:e[0])||\"\"}}function O(t){return t&&JSON.parse(_(JSON.stringify(t)).cleaned)}export{f as VERCEL_STEGA_REGEX,y as legacyStegaEncode,O as vercelStegaClean,C as vercelStegaCombine,G as vercelStegaDecode,$ as vercelStegaDecodeAll,E as vercelStegaEncode,_ as vercelStegaSplit};\n","import {\n  vercelStegaCombine,\n  vercelStegaDecode,\n  vercelStegaEncode,\n  vercelStegaSplit,\n} from '@vercel/stega';\n\nimport type { SourceMapMetadata } from './types.js';\n\nexport function combine(text: string, metadata: SourceMapMetadata): string {\n  return vercelStegaCombine(text, metadata);\n}\n\nexport function encode(metadata: SourceMapMetadata): string {\n  return vercelStegaEncode(metadata);\n}\n\nexport function decode(text: string): SourceMapMetadata | undefined {\n  return vercelStegaDecode(text);\n}\n\nexport function splitEncoding(text: string): {\n  /** The original string with encoded substring removed */\n  cleaned: string;\n  /** The encoded substring from the original string */\n  encoded: string;\n} {\n  return vercelStegaSplit(text);\n}\n","\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n","'use strict';\n\nvar each = require('foreach');\nmodule.exports = api;\n\n\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api (obj, pointer, value) {\n    // .set()\n    if (arguments.length === 3) {\n        return api.set(obj, pointer, value);\n    }\n    // .get()\n    if (arguments.length === 2) {\n        return api.get(obj, pointer);\n    }\n    // Return a partially applied function on `obj`.\n    var wrapped = api.bind(api, obj);\n\n    // Support for oo style\n    for (var name in api) {\n        if (api.hasOwnProperty(name)) {\n            wrapped[name] = api[name].bind(wrapped, obj);\n        }\n    }\n    return wrapped;\n}\n\n\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\napi.get = function get (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n    for (var i = 0; i < refTokens.length; ++i) {\n        var tok = refTokens[i];\n        if (!(typeof obj == 'object' && tok in obj)) {\n            throw new Error('Invalid reference token: ' + tok);\n        }\n        obj = obj[tok];\n    }\n    return obj;\n};\n\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\napi.set = function set (obj, pointer, value) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n    if (refTokens.length === 0) {\n      throw Error('Can not set the root object');\n    }\n\n    for (var i = 0; i < refTokens.length - 1; ++i) {\n        var tok = refTokens[i];\n        if (typeof tok !== 'string' && typeof tok !== 'number') {\n          tok = String(tok)\n        }\n        if (tok === \"__proto__\" || tok === \"constructor\" || tok === \"prototype\") {\n            continue\n        }\n        if (tok === '-' && Array.isArray(obj)) {\n          tok = obj.length;\n        }\n        nextTok = refTokens[i + 1];\n\n        if (!(tok in obj)) {\n            if (nextTok.match(/^(\\d+|-)$/)) {\n                obj[tok] = [];\n            } else {\n                obj[tok] = {};\n            }\n        }\n        obj = obj[tok];\n    }\n    if (nextTok === '-' && Array.isArray(obj)) {\n      nextTok = obj.length;\n    }\n    obj[nextTok] = value;\n    return this;\n};\n\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\napi.remove = function (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n    var finalToken = refTokens[refTokens.length -1];\n    if (finalToken === undefined) {\n        throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n    }\n\n    var parent = api.get(obj, refTokens.slice(0, -1));\n    if (Array.isArray(parent)) {\n      var index = +finalToken;\n      if (finalToken === '' && isNaN(index)) {\n        throw new Error('Invalid array index: \"' + finalToken + '\"');\n      }\n\n      Array.prototype.splice.call(parent, index, 1);\n    } else {\n      delete parent[finalToken];\n    }\n};\n\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\napi.dict = function dict (obj, descend) {\n    var results = {};\n    api.walk(obj, function (value, pointer) {\n        results[pointer] = value;\n    }, descend);\n    return results;\n};\n\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\napi.walk = function walk (obj, iterator, descend) {\n    var refTokens = [];\n\n    descend = descend || function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Object]' || type === '[object Array]';\n    };\n\n    (function next (cur) {\n        each(cur, function (value, key) {\n            refTokens.push(String(key));\n            if (descend(value)) {\n                next(value);\n            } else {\n                iterator(value, api.compile(refTokens));\n            }\n            refTokens.pop();\n        });\n    }(obj));\n};\n\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\napi.has = function has (obj, pointer) {\n    try {\n        api.get(obj, pointer);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.escape = function escape (str) {\n    return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.unescape = function unescape (str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\napi.parse = function parse (pointer) {\n    if (pointer === '') { return []; }\n    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }\n    return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\napi.compile = function compile (refTokens) {\n    if (refTokens.length === 0) { return ''; }\n    return '/' + refTokens.map(api.escape).join('/');\n};\n","import { get, set } from 'json-pointer';\n\nimport { combine } from './encode.js';\nimport type { CPAMappings, GraphQLMappings, SourceMapMetadata } from './types.js';\n\nexport const encodeRichTextValue = ({\n  pointer,\n  mappings,\n  data,\n  hiddenStrings,\n}: {\n  pointer: string;\n  mappings: CPAMappings | GraphQLMappings;\n  data: Node;\n  hiddenStrings: SourceMapMetadata;\n}) => {\n  const source = mappings[pointer];\n\n  // Only proceed with mapping if we have a valid source\n  if (source) {\n    // We can now safely delete the original pointer as we've preserved the source\n    delete mappings[pointer];\n\n    const textNodes = findRichTextNodes(data, pointer);\n    for (const textNode of textNodes) {\n      mappings[textNode] = source;\n      const currentTextNodeValue = get(data, textNode);\n      const encodedValue = combine(currentTextNodeValue, hiddenStrings);\n      set(data, textNode, encodedValue);\n    }\n  } else {\n    // If there's no source mapping, just encode the text nodes without creating mappings\n    const textNodes = findRichTextNodes(data, pointer);\n    for (const textNode of textNodes) {\n      const currentTextNodeValue = get(data, textNode);\n      const encodedValue = combine(currentTextNodeValue, hiddenStrings);\n      set(data, textNode, encodedValue);\n    }\n  }\n};\n\nconst findRichTextNodes = (data: Node, currentPath = ''): string[] => {\n  const textNodes = [];\n  const node = get(data, currentPath);\n\n  if (node.content) {\n    for (let i = 0; i < node.content.length; i++) {\n      if (node.content[i].nodeType === 'text') {\n        textNodes.push(`${currentPath}/content/${i}/value`);\n      } else {\n        textNodes.push(...findRichTextNodes(data, `${currentPath}/content/${i}`));\n      }\n    }\n  }\n\n  return textNodes;\n};\n","import { set } from 'json-pointer';\n\nimport { combine } from './encode.js';\nimport { encodeRichTextValue } from './richText.js';\nimport type {\n  CPAEntry,\n  CPAMappings,\n  CreateSourceMapParams,\n  FieldType,\n  GraphQLMappings,\n  GraphQLResponse,\n  SourceMapMetadata,\n  WidgetId,\n  WidgetNamespace,\n} from './types.js';\n\nexport const createSourceMapMetadata = ({\n  entityId,\n  entityType,\n  space,\n  environment,\n  field,\n  locale,\n  editorInterface,\n  fieldType,\n  targetOrigin,\n  platform,\n}: CreateSourceMapParams): SourceMapMetadata => {\n  const targetOriginUrl = targetOrigin || 'https://app.contentful.com';\n  const basePath = `${targetOriginUrl}/spaces/${space}/environments/${environment}`;\n  const entityRoute = entityType === 'Entry' ? 'entries' : 'assets';\n  const href = `${basePath}/${entityRoute}/${entityId}/?focusedField=${field}&focusedLocale=${locale}&source=vercel-content-link`;\n\n  const result: SourceMapMetadata = {\n    origin: 'contentful.com',\n    href,\n    contentful: {\n      editorInterface,\n      fieldType,\n    },\n  };\n\n  // If the user has specified a platform, we remove the fields that are not relevant to that platform\n  if (platform === 'vercel') {\n    delete result.contentful;\n  }\n\n  return result;\n};\n\nexport const isBuiltinNamespace = (namespace: WidgetNamespace) =>\n  ['builtin', 'sidebar-builtin', 'editor-builtin'].includes(namespace);\nexport const isSupportedWidget = (widgetId: WidgetId) => SUPPORTED_WIDGETS.includes(widgetId);\n\n/**\n * Clones the incoming element into a new one, to prevent modification on the original object\n * Hint: It uses the structuredClone which is only available in modern browsers,\n * for older one it uses the JSON.parse(JSON.stringify) hack.\n */\nexport function clone<T extends Record<string, unknown> | Array<unknown>>(incoming: T): T {\n  if (typeof structuredClone === 'function') {\n    return structuredClone(incoming);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(incoming));\n  } catch (err) {\n    console.warn('Failed to clone data:', incoming, err);\n    return incoming;\n  }\n}\n\nexport const SUPPORTED_WIDGETS: WidgetId[] = [\n  'singleLine',\n  'tagEditor',\n  'listInput',\n  'checkbox',\n  'richTextEditor',\n  'multipleLine',\n];\n\nexport function encodeField(\n  fieldType: FieldType,\n  currentValue: any,\n  hiddenStrings: SourceMapMetadata,\n  target: GraphQLResponse | CPAEntry,\n  pointer: string,\n  mappings: CPAMappings | GraphQLMappings,\n  locale?: string,\n) {\n  // Determine the value based on locale (if provided)\n  const value = locale ? currentValue[locale] : currentValue;\n\n  // Process based on fieldType\n  switch (fieldType) {\n    case 'Symbol': {\n      const encodedValue = combine(value, hiddenStrings);\n      set(target, pointer, encodedValue);\n      break;\n    }\n\n    case 'Text': {\n      const encodedValue = combine(value, hiddenStrings);\n      set(target, pointer, encodedValue);\n      break;\n    }\n\n    case 'RichText': {\n      encodeRichTextValue({\n        pointer: '',\n        mappings,\n        data: value,\n        hiddenStrings,\n      });\n      break;\n    }\n\n    case 'Array': {\n      const encodedArray = value.map((item: unknown) => {\n        if (typeof item === 'string') {\n          return combine(item, hiddenStrings);\n        } else {\n          return item; // Return the item unchanged if it's not a string\n        }\n      });\n      set(target, pointer, encodedArray);\n      break;\n    }\n  }\n}\n","import { get, has } from 'json-pointer';\n\nimport type { CreateSourceMapParams } from '../types.js';\nimport {\n  clone,\n  createSourceMapMetadata,\n  encodeField,\n  isBuiltinNamespace,\n  isSupportedWidget,\n} from '../utils.js';\n\nexport const encodeGraphQLResponse = <TResponse extends { data: any; extensions: any }>(\n  originalGraphqlResponse: TResponse,\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n): TResponse => {\n  if (\n    !originalGraphqlResponse ||\n    !originalGraphqlResponse.extensions ||\n    !originalGraphqlResponse.extensions.contentSourceMaps\n  ) {\n    console.error(\n      'GraphQL response does not contain Content Source Maps information.',\n      originalGraphqlResponse,\n    );\n    return originalGraphqlResponse;\n  }\n  const modifiedGraphqlResponse = clone(originalGraphqlResponse);\n  const {\n    spaces,\n    environments,\n    editorInterfaces,\n    fields,\n    locales,\n    entries,\n    assets,\n    mappings,\n    fieldTypes,\n  } = modifiedGraphqlResponse.extensions.contentSourceMaps;\n  const target = modifiedGraphqlResponse;\n\n  for (const pointer in mappings) {\n    const { source } = mappings[pointer];\n\n    const entity = 'entry' in source ? entries[source.entry] : assets[source.asset];\n    const entityType = 'entry' in source ? 'Entry' : 'Asset';\n\n    if (!entity) {\n      return modifiedGraphqlResponse;\n    }\n\n    const space = spaces[entity.space];\n    const environment = environments[entity.environment];\n    const entityId = entity.id;\n    const field = fields[source.field];\n    const locale = locales[source.locale];\n    const editorInterface = editorInterfaces[source.editorInterface];\n    const fieldType = fieldTypes[source.fieldType];\n\n    // Skip unsupported widgets\n    if (\n      isBuiltinNamespace(editorInterface.widgetNamespace) &&\n      !isSupportedWidget(editorInterface.widgetId)\n    ) {\n      continue;\n    }\n\n    if (has(target, pointer)) {\n      const currentValue = get(target, pointer);\n\n      if (currentValue !== null) {\n        const hiddenStrings = createSourceMapMetadata({\n          entityId,\n          entityType,\n          space,\n          environment,\n          field,\n          locale,\n          editorInterface,\n          fieldType,\n          targetOrigin,\n          platform,\n        });\n\n        encodeField(fieldType, currentValue, hiddenStrings, target, pointer, mappings);\n      }\n    } else {\n      //@TODO - add Sentry logging\n      // console.warn(`Pointer ${pointer} not found in the entry`, target);\n    }\n  }\n  return modifiedGraphqlResponse;\n};\n","import { get, has } from 'json-pointer';\n\nimport type {\n  CPAEntry,\n  CPAEntryCollection,\n  EditorInterfaceSource,\n  FieldType,\n  CreateSourceMapParams,\n} from '../types.js';\nimport {\n  clone,\n  createSourceMapMetadata,\n  encodeField,\n  isBuiltinNamespace,\n  isSupportedWidget,\n} from '../utils.js';\n\nconst applyEncoding = (\n  target: CPAEntry,\n  fieldTypes: FieldType[],\n  editorInterfaces: EditorInterfaceSource[],\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n) => {\n  if (!target.fields) {\n    return;\n  }\n\n  const { contentSourceMaps } = target.sys;\n\n  // Skip if there are no source maps\n  // For example if an entry has only one unsupported field\n  if (!contentSourceMaps) {\n    return;\n  }\n\n  const { mappings } = contentSourceMaps;\n\n  for (const pointer in mappings) {\n    const { source } = mappings[pointer];\n    const space = target.sys.space.sys.id;\n    const environment = target.sys.environment.sys.id;\n    const entityId = target.sys.id;\n    const entityType = target.sys.type;\n    const fieldType = fieldTypes[source.fieldType];\n    const editorInterface = editorInterfaces[source.editorInterface];\n\n    // Skip unsupported widgets\n    if (\n      isBuiltinNamespace(editorInterface.widgetNamespace) &&\n      !isSupportedWidget(editorInterface.widgetId)\n    ) {\n      continue;\n    }\n\n    const formattedPointer = pointer.startsWith('/') ? pointer : `/${pointer}`;\n\n    if (has(target, formattedPointer)) {\n      const currentValue = get(target, formattedPointer);\n      if (currentValue === null) {\n        return;\n      }\n      const fieldParts = formattedPointer.split('/'); // Split the pointer into parts\n      const field = fieldParts.pop(); // Get the last part, which is the field name\n      if (!field) {\n        console.error('Field name could not be extracted from the pointer', formattedPointer);\n        return;\n      }\n      const locale = target.sys.locale;\n\n      // Determine if we are dealing with multiple locale values in the response or just a single locale\n      if (locale) {\n        const hiddenStrings = createSourceMapMetadata({\n          entityId,\n          entityType,\n          space,\n          environment,\n          field,\n          locale,\n          editorInterface,\n          fieldType,\n          targetOrigin,\n          platform,\n        });\n\n        encodeField(fieldType, currentValue, hiddenStrings, target, formattedPointer, mappings);\n      } else {\n        const locales = Object.keys(currentValue);\n        locales.forEach((locale) => {\n          const hiddenStrings = createSourceMapMetadata({\n            entityId,\n            entityType,\n            space,\n            environment,\n            field,\n            locale,\n            editorInterface,\n            fieldType,\n            targetOrigin,\n            platform,\n          });\n\n          encodeField(\n            fieldType,\n            currentValue,\n            hiddenStrings,\n            target,\n            `${formattedPointer}/${locale}`,\n            mappings,\n            locale,\n          );\n        });\n      }\n    } else {\n      //@TODO - add Sentry logging\n      // console.warn(`Pointer ${pointer} not found in the entry`, target);\n    }\n  }\n};\n\nexport const encodeCPAResponse = (\n  CPAResponse: CPAEntry | CPAEntryCollection,\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n): CPAEntry | CPAEntryCollection => {\n  const modifiedCPAResponse = clone(\n    CPAResponse as unknown as Record<string, unknown>,\n  ) as unknown as CPAEntry | CPAEntryCollection;\n\n  // Entity collections\n  if (modifiedCPAResponse.sys && 'items' in (modifiedCPAResponse as CPAEntryCollection)) {\n    const collection = modifiedCPAResponse as CPAEntryCollection;\n    if (!collection.sys?.contentSourceMapsLookup) {\n      return collection;\n    }\n    const {\n      contentSourceMapsLookup: { fieldTypes, editorInterfaces },\n    } = collection.sys;\n    const { items, includes } = collection;\n\n    items.forEach((target) =>\n      applyEncoding(target, fieldTypes, editorInterfaces, targetOrigin, platform),\n    );\n    if (includes && includes.Entry) {\n      includes.Entry.forEach((entry) =>\n        applyEncoding(entry, fieldTypes, editorInterfaces, targetOrigin, platform),\n      );\n    }\n    if (includes && includes.Asset) {\n      includes.Asset.forEach((asset) =>\n        applyEncoding(asset, fieldTypes, editorInterfaces, targetOrigin, platform),\n      );\n    }\n    // Single entity\n  } else {\n    const entry = modifiedCPAResponse as CPAEntry;\n    if (!entry.sys.contentSourceMapsLookup) {\n      console.error('Content source maps lookup data is missing');\n      return entry;\n    }\n\n    applyEncoding(\n      entry,\n      entry.sys.contentSourceMapsLookup.fieldTypes,\n      entry.sys.contentSourceMapsLookup.editorInterfaces,\n      targetOrigin,\n      platform,\n    );\n  }\n\n  return modifiedCPAResponse;\n};\n"],"mappings":"AAAA,IAAIA,CAAA,GAAE;IAAC,GAAE;IAAK,GAAE;IAAK,GAAE;IAAK,GAAE;IAAK,GAAE;IAAK,GAAE;IAAK,GAAE;IAAM,GAAE;IAAK,GAAE;IAAO,GAAE;IAAOC,CAAA,EAAE;IAAOC,CAAA,EAAE;IAAOC,CAAA,EAAE;IAAOC,CAAA,EAAE;IAAOC,CAAA,EAAE;IAAOC,CAAA,EAAE;EAAM;EAAEC,CAAA,GAAE;IAAC,GAAE;IAAK,GAAE;IAAK,GAAE;IAAK,GAAE;EAAK;EAAEC,CAAA,GAAE,IAAIC,KAAA,CAAM,CAAC,EAAEC,IAAA,CAAKC,MAAA,CAAOC,aAAA,CAAcL,CAAA,CAAE,CAAC,CAAC,CAAC,EAAEM,IAAA,CAAK,EAAE;EAAEC,CAAA,GAAE;AAAuB,SAASC,EAAEC,CAAA,EAAE;EAAC,IAAIC,CAAA,GAAEC,IAAA,CAAKC,SAAA,CAAUH,CAAC;EAAE,OAAM,GAAGR,CAAC,GAAGC,KAAA,CAAMW,IAAA,CAAKH,CAAC,EAAEI,GAAA,CAAIC,CAAA,IAAG;IAAC,IAAIjB,CAAA,GAAEiB,CAAA,CAAEC,UAAA,CAAW,CAAC;IAAE,IAAGlB,CAAA,GAAE,KAAI,MAAM,IAAImB,KAAA,CAAM,mEAAmEP,CAAC,iBAAiBK,CAAC,KAAKjB,CAAC,GAAG;IAAE,OAAOI,KAAA,CAAMW,IAAA,CAAKf,CAAA,CAAEoB,QAAA,CAAS,CAAC,EAAEC,QAAA,CAAS,GAAE,GAAG,CAAC,EAAEL,GAAA,CAAIM,CAAA,IAAGhB,MAAA,CAAOC,aAAA,CAAcL,CAAA,CAAEoB,CAAC,CAAC,CAAC,EAAEd,IAAA,CAAK,EAAE;EAAC,CAAC,EAAEA,IAAA,CAAK,EAAE,CAAC;AAAE;AAA6T,SAASe,EAAEZ,CAAA,EAAE;EAAC,OAAM,CAACa,MAAA,CAAOC,KAAA,CAAMD,MAAA,CAAOb,CAAC,CAAC,KAAG,SAASe,IAAA,CAAKf,CAAC,KAAG,CAAC,2DAA2De,IAAA,CAAKf,CAAC,IAAE,KAAG,EAAQgB,IAAA,CAAKC,KAAA,CAAMjB,CAAC;AAAE;AAAC,SAASkB,EAAElB,CAAA,EAAE;EAAC,IAAG;IAAC,IAAImB,GAAA,CAAInB,CAAA,EAAEA,CAAA,CAAEoB,UAAA,CAAW,GAAG,IAAE,qBAAmB,MAAM;EAAC,SAAMnB,CAAA;IAAC,OAAM;EAAE;EAAC;AAAQ;AAAC,SAASoB,EAAErB,CAAA,EAAEC,CAAA,EAAW;EAAA,IAATK,CAAA,GAAAgB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAE;EAAQ,OAAOhB,CAAA,KAAI,MAAIA,CAAA,KAAI,WAASM,CAAA,CAAEZ,CAAC,KAAGkB,CAAA,CAAElB,CAAC,KAAGA,CAAA,GAAE,GAAGA,CAAC,GAAGD,CAAA,CAAEE,CAAC,CAAC;AAAE;AAAC,IAAIwB,CAAA,GAAEC,MAAA,CAAOC,WAAA,CAAYD,MAAA,CAAOE,OAAA,CAAQrC,CAAC,EAAEc,GAAA,CAAIL,CAAA,IAAGA,CAAA,CAAE6B,OAAA,CAAO,CAAE,CAAC;EAAEC,CAAA,GAAEJ,MAAA,CAAOC,WAAA,CAAYD,MAAA,CAAOE,OAAA,CAAQ5C,CAAC,EAAEqB,GAAA,CAAIL,CAAA,IAAGA,CAAA,CAAE6B,OAAA,CAAS,EAAC;EAAEE,CAAA,GAAE,GAAGL,MAAA,CAAOM,MAAA,CAAOhD,CAAC,EAAEqB,GAAA,CAAIL,CAAA,IAAG,OAAOA,CAAA,CAAES,QAAA,CAAS,EAAE,CAAC,GAAG,EAAEZ,IAAA,CAAK,EAAE,CAAC;EAAGoC,CAAA,GAAE,IAAIC,MAAA,CAAO,IAAIH,CAAC,SAAQ,IAAI;AAAE,SAASI,EAAEnC,CAAA,EAAE;EAAC,IAAIC,CAAA,GAAED,CAAA,CAAEoC,KAAA,CAAMH,CAAC;EAAE,IAAKhC,CAAA,EAAE,OAAOoC,CAAA,CAAEpC,CAAA,CAAE,CAAC,GAAE,EAAE,EAAE,CAAC;AAAC;AAAoE,SAASoC,EAAErC,CAAA,EAAO;EAAA,IAALC,CAAA,GAAAqB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAE;EAAI,IAAIhB,CAAA,GAAEb,KAAA,CAAMW,IAAA,CAAKJ,CAAC;EAAE,IAAGM,CAAA,CAAEiB,MAAA,GAAO,MAAI;IAAG,IAAGjB,CAAA,CAAEiB,MAAA,GAAO,KAAG,CAACvB,CAAA,CAAEoB,UAAA,CAAW5B,CAAC,GAAE,OAAO8C,EAAA,CAAEhC,CAAA,EAAEL,CAAC;EAAA,OAAO,MAAM,IAAIO,KAAA,CAAM,iCAAiC;EAAE,IAAInB,CAAA,GAAE,EAAE;EAAC,SAAQsB,CAAA,GAAEL,CAAA,CAAEiB,MAAA,GAAO,MAAIZ,CAAA,KAAK;IAAC,IAAI4B,CAAA,GAAEjC,CAAA,CAAEkC,KAAA,CAAM7B,CAAA,GAAE,GAAEA,CAAA,GAAE,IAAE,CAAC,EAAEN,GAAA,CAAIlB,CAAA,IAAGsC,CAAA,CAAEtC,CAAA,CAAEsD,WAAA,CAAY,CAAC,CAAC,CAAC,EAAE5C,IAAA,CAAK,EAAE;IAAER,CAAA,CAAEqD,OAAA,CAAQ/C,MAAA,CAAOgD,YAAA,CAAaC,QAAA,CAASL,CAAA,EAAE,CAAC,CAAC,CAAC;EAAC;EAAC,IAAGtC,CAAA,EAAE;IAACZ,CAAA,CAAEwD,KAAA,CAAO;IAAC,IAAIlC,CAAA,GAAEtB,CAAA,CAAEyD,OAAA,CAAQhD,CAAC;IAAE,OAAOa,CAAA,KAAI,OAAKA,CAAA,GAAEtB,CAAA,CAAEkC,MAAA,GAAQ,CAACrB,IAAA,CAAKe,KAAA,CAAM5B,CAAA,CAAEmD,KAAA,CAAM,GAAE7B,CAAC,EAAEd,IAAA,CAAK,EAAE,CAAC,CAAC;EAAC;EAAC,OAAOR,CAAA,CAAEQ,IAAA,CAAK,EAAE,EAAEkD,KAAA,CAAMjD,CAAC,EAAEkD,MAAA,CAAOC,OAAO,EAAE5C,GAAA,CAAIM,CAAA,IAAGT,IAAA,CAAKe,KAAA,CAAMN,CAAC,CAAC;AAAC;AAAC,SAAS2B,GAAEtC,CAAA,EAAEC,CAAA,EAAE;EAAC,IAAIK,CAAA;EAAE,IAAIjB,CAAA,GAAE,EAAE;EAAC,SAAQ6D,CAAA,GAAElD,CAAA,CAAEuB,MAAA,GAAO,KAAG2B,CAAA,KAAK;IAAC,IAAIC,CAAA,GAAE,GAAGrB,CAAA,CAAE9B,CAAA,CAAEkD,CAAA,GAAE,CAAC,EAAET,WAAA,CAAY,CAAC,CAAC,CAAC,GAAGX,CAAA,CAAE9B,CAAA,CAAEkD,CAAA,GAAE,IAAE,CAAC,EAAET,WAAA,CAAY,CAAC,CAAC,CAAC;IAAGpD,CAAA,CAAEqD,OAAA,CAAQ/C,MAAA,CAAOgD,YAAA,CAAaC,QAAA,CAASO,CAAA,EAAE,EAAE,CAAC,CAAC;EAAC;EAAC,IAAIxC,CAAA,GAAE,EAAE;IAAC4B,CAAA,GAAE,CAAClD,CAAA,CAAEQ,IAAA,CAAK,EAAE,CAAC;IAAEV,CAAA,GAAE;EAAG,OAAKoD,CAAA,CAAEhB,MAAA,GAAQ;IAAC,IAAI2B,CAAA,GAAEX,CAAA,CAAEM,KAAA,CAAO;IAAC,IAAG;MAAC,IAAGlC,CAAA,CAAEyC,IAAA,CAAKlD,IAAA,CAAKe,KAAA,CAAMiC,CAAC,CAAC,GAAEjD,CAAA,EAAE,OAAOU,CAAA;IAAC,SAAOwC,CAAA,EAAE;MAAC,IAAG,CAAChE,CAAA,IAAI,MAAMgE,CAAA;MAAE,IAAIlE,CAAA,GAAE,GAAGqB,CAAA,GAAE6C,CAAA,CAAEE,OAAA,CAAQjB,KAAA,CAAM,oBAAoB,MAAI,OAAK,SAAO9B,CAAA,CAAE,CAAC;MAAG,IAAG,CAACrB,CAAA,EAAE,MAAMkE,CAAA;MAAEZ,CAAA,CAAEG,OAAA,CAAQQ,CAAA,CAAEI,SAAA,CAAU,GAAErE,CAAC,GAAEiE,CAAA,CAAEI,SAAA,CAAUrE,CAAC,CAAC;IAAC;EAAC;EAAC,OAAO0B,CAAA;AAAC;AAAC,SAAS4C,GAAEvD,CAAA,EAAE;EAAC,IAAIC,CAAA;EAAE,OAAM;IAACuD,OAAA,EAAQxD,CAAA,CAAEyD,OAAA,CAAQxB,CAAA,EAAE,EAAE;IAAEyB,OAAA,IAAUzD,CAAA,GAAED,CAAA,CAAEoC,KAAA,CAAMH,CAAC,MAAI,OAAK,SAAOhC,CAAA,CAAE,CAAC,MAAI;EAAE;AAAC;ACShgF,SAAA0D,EAAQ3D,CAAA,EAAcC,CAAA,EAAqC;EAClE,OAAAoB,CAAA,CAAmBrB,CAAA,EAAMC,CAAQ;AAC1C;AAEO,SAAS2D,GAAO5D,CAAA,EAAqC;EAC1D,OAAOD,CAAA,CAAkBC,CAAQ;AACnC;AAEO,SAAS6D,GAAO7D,CAAA,EAA6C;EAClE,OAAOmC,CAAA,CAAkBnC,CAAI;AAC/B;AAEO,SAAS8D,GAAc9D,CAAA,EAK5B;EACA,OAAOuD,EAAA,CAAiBvD,CAAI;AAC9B;;;;;EC3BA,IAAIA,CAAA,GAAS0B,MAAA,CAAOqC,SAAA,CAAUC,cAAA;IAC1B/D,CAAA,GAAWyB,MAAA,CAAOqC,SAAA,CAAUtD,QAAA;EAElB,OAAAwD,CAAA,GAAG,SAAAC,CAAkB7E,CAAA,EAAKsB,CAAA,EAAI4B,CAAA,EAAK;IAC7C,IAAItC,CAAA,CAASkE,IAAA,CAAKxD,CAAE,MAAM,qBACtB,MAAM,IAAIyD,SAAA,CAAU,6BAA6B;IAErD,IAAIjF,CAAA,GAAIE,CAAA,CAAIkC,MAAA;IACZ,IAAIpC,CAAA,KAAM,CAACA,CAAA,EACP,SAAS+D,CAAA,GAAI,GAAGA,CAAA,GAAI/D,CAAA,EAAG+D,CAAA,IACnBvC,CAAA,CAAGwD,IAAA,CAAK5B,CAAA,EAAKlD,CAAA,CAAI6D,CAAC,GAAGA,CAAA,EAAG7D,CAAG,OAG/B,SAAS8D,CAAA,IAAK9D,CAAA,EACNW,CAAA,CAAOmE,IAAA,CAAK9E,CAAA,EAAK8D,CAAC,KAClBxC,CAAA,CAAGwD,IAAA,CAAK5B,CAAA,EAAKlD,CAAA,CAAI8D,CAAC,GAAGA,CAAA,EAAG9D,CAAG;EAI1C,GAAA4E,CAAA;;;;;;EClBD,IAAIjE,CAAA,GAAOqE,EAAA,CAAkB;EAC7BC,CAAA,GAAiBrE,CAAA;EAejB,SAASA,EAAKK,CAAA,EAAKjB,CAAA,EAASsB,CAAA,EAAO;IAE/B,IAAIW,SAAA,CAAUC,MAAA,KAAW,GACrB,OAAOtB,CAAA,CAAIsE,GAAA,CAAIjE,CAAA,EAAKjB,CAAA,EAASsB,CAAK;IAGtC,IAAIW,SAAA,CAAUC,MAAA,KAAW,GACrB,OAAOtB,CAAA,CAAIuE,GAAA,CAAIlE,CAAA,EAAKjB,CAAO;IAG/B,IAAIkD,CAAA,GAAUtC,CAAA,CAAIwE,IAAA,CAAKxE,CAAA,EAAKK,CAAG;IAG/B,SAASnB,CAAA,IAAQc,CAAA,EACTA,CAAA,CAAI+D,cAAA,CAAe7E,CAAI,MACvBoD,CAAA,CAAQpD,CAAI,IAAIc,CAAA,CAAId,CAAI,EAAEsF,IAAA,CAAKlC,CAAA,EAASjC,CAAG;IAGnD,OAAOiC,CAAA;EACX;EAUA,OAAAtC,CAAA,CAAIuE,GAAA,GAAM,UAAcnF,CAAA,EAAKsB,CAAA,EAAS;IAGlC,SAFI4B,CAAA,GAAY9C,KAAA,CAAMiF,OAAA,CAAQ/D,CAAO,IAAIA,CAAA,GAAUV,CAAA,CAAIgB,KAAA,CAAMN,CAAO,GAE3DxB,CAAA,GAAI,GAAGA,CAAA,GAAIoD,CAAA,CAAUhB,MAAA,EAAQ,EAAEpC,CAAA,EAAG;MACvC,IAAI+D,CAAA,GAAMX,CAAA,CAAUpD,CAAC;MACrB,IAAI,EAAE,OAAOE,CAAA,IAAO,YAAY6D,CAAA,IAAO7D,CAAA,GACnC,MAAM,IAAImB,KAAA,CAAM,8BAA8B0C,CAAG;MAErD7D,CAAA,GAAMA,CAAA,CAAI6D,CAAG;IACrB;IACI,OAAO7D,CAAA;EACV,GASDY,CAAA,CAAIsE,GAAA,GAAM,UAAclF,CAAA,EAAKsB,CAAA,EAAS4B,CAAA,EAAO;IACzC,IAAIpD,CAAA,GAAYM,KAAA,CAAMiF,OAAA,CAAQ/D,CAAO,IAAIA,CAAA,GAAUV,CAAA,CAAIgB,KAAA,CAAMN,CAAO;MAClEuC,CAAA,GAAU/D,CAAA,CAAU,CAAC;IAEvB,IAAIA,CAAA,CAAUoC,MAAA,KAAW,GACvB,MAAMf,KAAA,CAAM,6BAA6B;IAG3C,SAAS2C,CAAA,GAAI,GAAGA,CAAA,GAAIhE,CAAA,CAAUoC,MAAA,GAAS,GAAG,EAAE4B,CAAA,EAAG;MAC3C,IAAIlE,CAAA,GAAME,CAAA,CAAUgE,CAAC;MACjB,OAAOlE,CAAA,IAAQ,YAAY,OAAOA,CAAA,IAAQ,aAC5CA,CAAA,GAAMU,MAAA,CAAOV,CAAG,IAEd,EAAAA,CAAA,KAAQ,eAAeA,CAAA,KAAQ,iBAAiBA,CAAA,KAAQ,iBAGxDA,CAAA,KAAQ,OAAOQ,KAAA,CAAMiF,OAAA,CAAQrF,CAAG,MAClCJ,CAAA,GAAMI,CAAA,CAAIkC,MAAA,GAEZ2B,CAAA,GAAU/D,CAAA,CAAUgE,CAAA,GAAI,CAAC,GAEnBlE,CAAA,IAAOI,CAAA,KACL6D,CAAA,CAAQd,KAAA,CAAM,WAAW,IACzB/C,CAAA,CAAIJ,CAAG,IAAI,EAAE,GAEbI,CAAA,CAAIJ,CAAG,IAAI,CAAE,IAGrBI,CAAA,GAAMA,CAAA,CAAIJ,CAAG;IACrB;IACI,OAAIiE,CAAA,KAAY,OAAOzD,KAAA,CAAMiF,OAAA,CAAQrF,CAAG,MACtC6D,CAAA,GAAU7D,CAAA,CAAIkC,MAAA,GAEhBlC,CAAA,CAAI6D,CAAO,IAAIX,CAAA,EACR;EACV,GAQDtC,CAAA,CAAI0E,MAAA,GAAS,UAAUrE,CAAA,EAAKjB,CAAA,EAAS;IACjC,IAAIsB,CAAA,GAAYlB,KAAA,CAAMiF,OAAA,CAAQrF,CAAO,IAAIA,CAAA,GAAUY,CAAA,CAAIgB,KAAA,CAAM5B,CAAO;MAChEkD,CAAA,GAAa5B,CAAA,CAAUA,CAAA,CAAUY,MAAA,GAAQ,CAAC;IAC9C,IAAIgB,CAAA,KAAe,QACf,MAAM,IAAI/B,KAAA,CAAM,uCAAuCnB,CAAA,GAAU,GAAG;IAGxE,IAAIF,CAAA,GAASc,CAAA,CAAIuE,GAAA,CAAIlE,CAAA,EAAKK,CAAA,CAAU6B,KAAA,CAAM,GAAG,EAAE,CAAC;IAChD,IAAI/C,KAAA,CAAMiF,OAAA,CAAQvF,CAAM,GAAG;MACzB,IAAI+D,CAAA,GAAQ,CAACX,CAAA;MACb,IAAIA,CAAA,KAAe,MAAMzB,KAAA,CAAMoC,CAAK,GAClC,MAAM,IAAI1C,KAAA,CAAM,2BAA2B+B,CAAA,GAAa,GAAG;MAG7D9C,KAAA,CAAMsE,SAAA,CAAUa,MAAA,CAAOT,IAAA,CAAKhF,CAAA,EAAQ+D,CAAA,EAAO,CAAC;IAClD,OACM,OAAO/D,CAAA,CAAOoD,CAAU;EAE7B,GASDtC,CAAA,CAAI4E,IAAA,GAAO,UAAexF,CAAA,EAAKsB,CAAA,EAAS;IACpC,IAAI4B,CAAA,GAAU,CAAE;IAChB,OAAAtC,CAAA,CAAI6E,IAAA,CAAKzF,CAAA,EAAK,UAAUF,CAAA,EAAO+D,CAAA,EAAS;MACpCX,CAAA,CAAQW,CAAO,IAAI/D,CAAA;IACtB,GAAEwB,CAAO,GACH4B,CAAA;EACV,GAUDtC,CAAA,CAAI6E,IAAA,GAAO,UAAezF,CAAA,EAAKsB,CAAA,EAAU4B,CAAA,EAAS;IAC9C,IAAIpD,CAAA,GAAY,EAAE;IAElBoD,CAAA,GAAUA,CAAA,IAAW,UAAUW,CAAA,EAAO;MAClC,IAAIC,CAAA,GAAOzB,MAAA,CAAOqC,SAAA,CAAUtD,QAAA,CAAS0D,IAAA,CAAKjB,CAAK;MAC/C,OAAOC,CAAA,KAAS,qBAAqBA,CAAA,KAAS;IACjD,GAEA,SAASD,EAAMC,CAAA,EAAK;MACjBnD,CAAA,CAAKmD,CAAA,EAAK,UAAUlE,CAAA,EAAO8F,CAAA,EAAK;QAC5B5F,CAAA,CAAUiE,IAAA,CAAKzD,MAAA,CAAOoF,CAAG,CAAC,GACtBxC,CAAA,CAAQtD,CAAK,IACbiE,CAAA,CAAKjE,CAAK,IAEV0B,CAAA,CAAS1B,CAAA,EAAOgB,CAAA,CAAI+E,OAAA,CAAQ7F,CAAS,CAAC,GAE1CA,CAAA,CAAU8F,GAAA,CAAK;MAC3B,CAAS;IACJ,EAAC5F,CAAG;EACR,GASDY,CAAA,CAAIiF,GAAA,GAAM,UAAc7F,CAAA,EAAKsB,CAAA,EAAS;IAClC,IAAI;MACAV,CAAA,CAAIuE,GAAA,CAAInF,CAAA,EAAKsB,CAAO;IACvB,SAAQ4B,CAAA,EAAG;MACR,OAAO;IACf;IACI,OAAO;EACV,GAQDtC,CAAA,CAAIkF,MAAA,GAAS,UAAiB9F,CAAA,EAAK;IAC/B,OAAOA,CAAA,CAAIoB,QAAA,CAAU,EAACgD,OAAA,CAAQ,MAAM,IAAI,EAAEA,OAAA,CAAQ,OAAO,IAAI;EAChE,GAQDxD,CAAA,CAAImF,QAAA,GAAW,UAAmB/F,CAAA,EAAK;IACnC,OAAOA,CAAA,CAAIoE,OAAA,CAAQ,OAAO,GAAG,EAAEA,OAAA,CAAQ,OAAO,GAAG;EACpD,GAQDxD,CAAA,CAAIgB,KAAA,GAAQ,UAAgB5B,CAAA,EAAS;IACjC,IAAIA,CAAA,KAAY,IAAM,OAAO;IAC7B,IAAIA,CAAA,CAAQgG,MAAA,CAAO,CAAC,MAAM,KAAO,MAAM,IAAI7E,KAAA,CAAM,2BAA2BnB,CAAO;IACnF,OAAOA,CAAA,CAAQiE,SAAA,CAAU,CAAC,EAAEP,KAAA,CAAM,IAAI,EAAE1C,GAAA,CAAIJ,CAAA,CAAImF,QAAQ;EAC3D,GAQDnF,CAAA,CAAI+E,OAAA,GAAU,UAAkB3F,CAAA,EAAW;IACvC,OAAIA,CAAA,CAAUkC,MAAA,KAAW,IAAY,KAC9B,MAAMlC,CAAA,CAAUgB,GAAA,CAAIJ,CAAA,CAAIkF,MAAM,EAAEtF,IAAA,CAAK,GAAG;EAClD,GAAAyE,CAAA;;;AClOM,MAAMgB,EAAA,GAAsBC,IAAA,IAU7B;IAAA,IAV8B;MAClCC,OAAA,EAAAxF,CAAA;MACAyF,QAAA,EAAAxF,CAAA;MACAyF,IAAA,EAAApF,CAAA;MACAqF,aAAA,EAAAtG;IACF,IAAAkG,IAAA;IAMQ,MAAA5E,CAAA,GAASV,CAAA,CAASD,CAAO;IAG/B,IAAIW,CAAA,EAAQ;MAEV,OAAOV,CAAA,CAASD,CAAO;MAEjB,MAAAuC,CAAA,GAAYrD,CAAA,CAAkBoB,CAAA,EAAMN,CAAO;MACjD,WAAWb,CAAA,IAAYoD,CAAA,EAAW;QAChCtC,CAAA,CAASd,CAAQ,IAAIwB,CAAA;QACf,MAAAuC,CAAA,GAAuB0C,CAAA,CAAApB,GAAA,CAAIlE,CAAA,EAAMnB,CAAQ;UACzCgE,CAAA,GAAeQ,CAAA,CAAQT,CAAA,EAAsB7D,CAAa;QAC5DuG,CAAA,CAAArB,GAAA,CAAAjE,CAAA,EAAMnB,CAAA,EAAUgE,CAAY;MAAA;IAClC,OACK;MAEC,MAAAZ,CAAA,GAAYrD,CAAA,CAAkBoB,CAAA,EAAMN,CAAO;MACjD,WAAWb,CAAA,IAAYoD,CAAA,EAAW;QAC1B,MAAAW,CAAA,GAAuB0C,CAAA,CAAApB,GAAA,CAAIlE,CAAA,EAAMnB,CAAQ;UACzCgE,CAAA,GAAeQ,CAAA,CAAQT,CAAA,EAAsB7D,CAAa;QAC5DuG,CAAA,CAAArB,GAAA,CAAAjE,CAAA,EAAMnB,CAAA,EAAUgE,CAAY;MAAA;IAClC;EAEJ;EAEMjE,CAAA,GAAoB,SAAA2G,CAAC7F,CAAA,EAA2C;IAAA,IAA/BC,CAAA,GAAAqB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAc;IACnD,MAAMhB,CAAA,GAAY,EAAC;MACbjB,CAAA,GAAOuG,CAAA,CAAApB,GAAA,CAAIxE,CAAA,EAAMC,CAAW;IAElC,IAAIZ,CAAA,CAAKyG,OAAA,EACP,SAASnF,CAAA,GAAI,GAAGA,CAAA,GAAItB,CAAA,CAAKyG,OAAA,CAAQvE,MAAA,EAAQZ,CAAA,IACnCtB,CAAA,CAAKyG,OAAA,CAAQnF,CAAC,EAAEoF,QAAA,KAAa,SAC/BzF,CAAA,CAAU8C,IAAA,CAAK,GAAGnD,CAAW,YAAYU,CAAC,QAAQ,IAExCL,CAAA,CAAA8C,IAAA,CAAK,GAAGlE,CAAA,CAAkBc,CAAA,EAAM,GAAGC,CAAW,YAAYU,CAAC,EAAE,CAAC;IAKvE,OAAAL,CAAA;EACT;ECxCa0F,CAAA,GAA0BC,KAAA,IAWS;IAAA,IAXR;MACtCC,QAAA,EAAAlG,CAAA;MACAmG,UAAA,EAAAlG,CAAA;MACAmG,KAAA,EAAA9F,CAAA;MACA+F,WAAA,EAAAhH,CAAA;MACAiH,KAAA,EAAA3F,CAAA;MACA4F,MAAA,EAAAhE,CAAA;MACAiE,eAAA,EAAArH,CAAA;MACAsH,SAAA,EAAAvD,CAAA;MACAwD,YAAA,EAAAvD,CAAA;MACAwD,QAAA,EAAA1H;IACF,IAAAgH,KAAA;IAME,MAAM7G,CAAA,GAA4B;MAChCwH,MAAA,EAAQ;MACRC,IAAA,EAJW,GAFI,GADO1D,CAAA,IAAgB,4BACL,WAAW7C,CAAK,iBAAiBjB,CAAW,EAEvD,IADJY,CAAA,KAAe,UAAU,YAAY,QAClB,IAAID,CAAQ,kBAAkBW,CAAK,kBAAkB4B,CAAM;MAKhGuE,UAAA,EAAY;QACVN,eAAA,EAAArH,CAAA;QACAsH,SAAA,EAAAvD;MAAA;IAEJ;IAGA,OAAIjE,CAAA,KAAa,YACf,OAAOG,CAAA,CAAO0H,UAAA,EAGT1H,CAAA;EACT;EAEa2H,CAAA,GAAsB/G,CAAA,IACjC,CAAC,WAAW,mBAAmB,gBAAgB,EAAEgH,QAAA,CAAShH,CAAS;EACxDiH,CAAA,GAAqBjH,CAAA,IAAuBkH,EAAA,CAAkBF,QAAA,CAAShH,CAAQ;AAOrF,SAASmH,EAA0DnH,CAAA,EAAgB;EACpF,WAAOoH,eAAA,IAAoB,YAC7B,OAAOA,eAAA,CAAgBpH,CAAQ;EAG7B;IACF,OAAOE,IAAA,CAAKe,KAAA,CAAMf,IAAA,CAAKC,SAAA,CAAUH,CAAQ,CAAC;EAAA,SACnCC,CAAA,EAAK;IACJ,OAAAoH,OAAA,CAAAC,IAAA,CAAK,yBAAyBtH,CAAA,EAAUC,CAAG,GAC5CD,CAAA;EAAA;AAEX;AAEO,MAAMkH,EAAA,GAAgC,CAC3C,cACA,aACA,aACA,YACA,kBACA,eACF;AAEO,SAASK,EACdvH,CAAA,EACAC,CAAA,EACAK,CAAA,EACAjB,CAAA,EACAsB,CAAA,EACA4B,CAAA,EACApD,CAAA,EACA;EAEA,MAAM+D,CAAA,GAAQ/D,CAAA,GAASc,CAAA,CAAad,CAAM,IAAIc,CAAA;EAG9C,QAAQD,CAAA;IACN,KAAK;MAAU;QACP,MAAAmD,CAAA,GAAeQ,CAAA,CAAQT,CAAA,EAAO5C,CAAa;QAC7CsF,CAAA,CAAArB,GAAA,CAAAlF,CAAA,EAAQsB,CAAA,EAASwC,CAAY;QACjC;MAAA;IAGF,KAAK;MAAQ;QACL,MAAAA,CAAA,GAAeQ,CAAA,CAAQT,CAAA,EAAO5C,CAAa;QAC7CsF,CAAA,CAAArB,GAAA,CAAAlF,CAAA,EAAQsB,CAAA,EAASwC,CAAY;QACjC;MAAA;IAGF,KAAK;MAAY;QACKmC,EAAA;UAClBE,OAAA,EAAS;UACTC,QAAA,EAAAlD,CAAA;UACAmD,IAAA,EAAMxC,CAAA;UACNyC,aAAA,EAAArF;QAAA,CACD;QACD;MAAA;IAGF,KAAK;MAAS;QACZ,MAAM6C,CAAA,GAAeD,CAAA,CAAM7C,GAAA,CAAKpB,CAAA,IAC1B,OAAOA,CAAA,IAAS,WACX0E,CAAA,CAAQ1E,CAAA,EAAMqB,CAAa,IAE3BrB,CAEV;QACG2G,CAAA,CAAArB,GAAA,CAAAlF,CAAA,EAAQsB,CAAA,EAASwC,CAAY;QACjC;MAAA;EACF;AAEJ;ACtHO,MAAMqE,EAAA,GAAwBC,CACnCzH,CAAA,EACAC,CAAA,EACAK,CAAA,KACc;IAEZ,KAACN,CAAA,IACD,CAACA,CAAA,CAAwB0H,UAAA,IACzB,CAAC1H,CAAA,CAAwB0H,UAAA,CAAWC,iBAAA,EAE5B,OAAAN,OAAA,CAAAO,KAAA,CACN,sEACA5H,CACF,GACOA,CAAA;IAEH,MAAAX,CAAA,GAA0B8H,CAAA,CAAMnH,CAAuB;MACvD;QACJ6H,MAAA,EAAAlH,CAAA;QACAmH,YAAA,EAAAvF,CAAA;QACAwF,gBAAA,EAAA5I,CAAA;QACA6I,MAAA,EAAA9E,CAAA;QACA+E,OAAA,EAAA9E,CAAA;QACAvB,OAAA,EAAA3C,CAAA;QACAiJ,MAAA,EAAAnD,CAAA;QACAU,QAAA,EAAA0C,CAAA;QACAC,UAAA,EAAAC;MAAA,IACEhJ,CAAA,CAAwBqI,UAAA,CAAWC,iBAAA;MACjCW,CAAA,GAASjJ,CAAA;IAEf,WAAWD,CAAA,IAAW+I,CAAA,EAAU;MAC9B,MAAM;UAAEI,MAAA,EAAAjJ;QAAA,IAAW6I,CAAA,CAAS/I,CAAO;QAE7BoJ,CAAA,GAAS,WAAWlJ,CAAA,GAASL,CAAA,CAAQK,CAAA,CAAOmJ,KAAK,IAAI1D,CAAA,CAAOzF,CAAA,CAAOoJ,KAAK;QACxEC,CAAA,GAAa,WAAWrJ,CAAA,GAAS,UAAU;MAEjD,IAAI,CAACkJ,CAAA,EACI,OAAAnJ,CAAA;MAGH,MAAAuJ,CAAA,GAAQjI,CAAA,CAAO6H,CAAA,CAAOpC,KAAK;QAC3ByC,CAAA,GAActG,CAAA,CAAaiG,CAAA,CAAOnC,WAAW;QAC7CyC,CAAA,GAAWN,CAAA,CAAOO,EAAA;QAClBC,CAAA,GAAQ9F,CAAA,CAAO5D,CAAA,CAAOgH,KAAK;QAC3B2C,CAAA,GAAS9F,CAAA,CAAQ7D,CAAA,CAAOiH,MAAM;QAC9B2C,CAAA,GAAkB/J,CAAA,CAAiBG,CAAA,CAAOkH,eAAe;QACzD2C,CAAA,GAAYd,CAAA,CAAW/I,CAAA,CAAOmH,SAAS;MAI3C,MAAAM,CAAA,CAAmBmC,CAAA,CAAgBE,eAAe,KAClD,CAACnC,CAAA,CAAkBiC,CAAA,CAAgBG,QAAQ,MAKzCzD,CAAA,CAAAV,GAAA,CAAIoD,CAAA,EAAQlJ,CAAO,GAAG;QAClB,MAAAkK,CAAA,GAAe1D,CAAA,CAAApB,GAAA,CAAI8D,CAAA,EAAQlJ,CAAO;QAExC,IAAIkK,CAAA,KAAiB,MAAM;UACzB,MAAMC,CAAA,GAAgBvD,CAAA,CAAwB;YAC5CE,QAAA,EAAA4C,CAAA;YACA3C,UAAA,EAAAwC,CAAA;YACAvC,KAAA,EAAAwC,CAAA;YACAvC,WAAA,EAAAwC,CAAA;YACAvC,KAAA,EAAA0C,CAAA;YACAzC,MAAA,EAAA0C,CAAA;YACAzC,eAAA,EAAA0C,CAAA;YACAzC,SAAA,EAAA0C,CAAA;YACAzC,YAAA,EAAAzG,CAAA;YACA0G,QAAA,EAAArG;UAAA,CACD;UAEDiH,CAAA,CAAY4B,CAAA,EAAWG,CAAA,EAAcC,CAAA,EAAejB,CAAA,EAAQlJ,CAAA,EAAS+I,CAAQ;QAAA;MAC/E;IAIF;IAEK,OAAA9I,CAAA;EACT;EC3EMmK,CAAA,GAAgBC,CACpBzJ,CAAA,EACAC,CAAA,EACAK,CAAA,EACAjB,CAAA,EACAsB,CAAA,KACG;IACC,KAACX,CAAA,CAAOgI,MAAA,EACV;IAGI;MAAEL,iBAAA,EAAApF;IAAA,IAAsBvC,CAAA,CAAO0J,GAAA;IAIrC,IAAI,CAACnH,CAAA,EACH;IAGI;MAAEkD,QAAA,EAAAtG;IAAA,IAAaoD,CAAA;IAErB,WAAWW,CAAA,IAAW/D,CAAA,EAAU;MAC9B,MAAM;UAAEoJ,MAAA,EAAApF;QAAA,IAAWhE,CAAA,CAAS+D,CAAO;QAC7BjE,CAAA,GAAQe,CAAA,CAAO0J,GAAA,CAAItD,KAAA,CAAMsD,GAAA,CAAIX,EAAA;QAC7BhE,CAAA,GAAc/E,CAAA,CAAO0J,GAAA,CAAIrD,WAAA,CAAYqD,GAAA,CAAIX,EAAA;QACzCZ,CAAA,GAAWnI,CAAA,CAAO0J,GAAA,CAAIX,EAAA;QACtBV,CAAA,GAAarI,CAAA,CAAO0J,GAAA,CAAIC,IAAA;QACxBrB,CAAA,GAAYrI,CAAA,CAAWkD,CAAA,CAAOsD,SAAS;QACvCrH,CAAA,GAAkBkB,CAAA,CAAiB6C,CAAA,CAAOqD,eAAe;MAI7D,IAAAO,CAAA,CAAmB3H,CAAA,CAAgBgK,eAAe,KAClD,CAACnC,CAAA,CAAkB7H,CAAA,CAAgBiK,QAAQ,GAE3C;MAGF,MAAM/J,CAAA,GAAmB4D,CAAA,CAAQ9B,UAAA,CAAW,GAAG,IAAI8B,CAAA,GAAU,IAAIA,CAAO;MAEpE,IAAA0C,CAAA,CAAAV,GAAA,CAAIlF,CAAA,EAAQV,CAAgB,GAAG;QAC3B,MAAAkJ,CAAA,GAAe5C,CAAA,CAAApB,GAAA,CAAIxE,CAAA,EAAQV,CAAgB;QACjD,IAAIkJ,CAAA,KAAiB,MACnB;QAGI,MAAAI,CAAA,GADatJ,CAAA,CAAiByD,KAAA,CAAM,GAAG,EACpBkC,GAAA,CAAI;QAC7B,IAAI,CAAC2D,CAAA,EAAO;UACFvB,OAAA,CAAAO,KAAA,CAAM,sDAAsDtI,CAAgB;UACpF;QAAA;QAEI,MAAAuJ,CAAA,GAAS7I,CAAA,CAAO0J,GAAA,CAAInD,MAAA;QAG1B,IAAIsC,CAAA,EAAQ;UACV,MAAMC,CAAA,GAAgB9C,CAAA,CAAwB;YAC5CE,QAAA,EAAAiC,CAAA;YACAhC,UAAA,EAAAkC,CAAA;YACAjC,KAAA,EAAAnH,CAAA;YACAoH,WAAA,EAAAtB,CAAA;YACAuB,KAAA,EAAAsC,CAAA;YACArC,MAAA,EAAAsC,CAAA;YACArC,eAAA,EAAApH,CAAA;YACAqH,SAAA,EAAA6B,CAAA;YACA5B,YAAA,EAAArH,CAAA;YACAsH,QAAA,EAAAhG;UAAA,CACD;UAED4G,CAAA,CAAYe,CAAA,EAAWE,CAAA,EAAcM,CAAA,EAAe9I,CAAA,EAAQV,CAAA,EAAkBH,CAAQ;QAAA,OAEtEuC,MAAA,CAAOkI,IAAA,CAAKpB,CAAY,EAChCqB,OAAA,CAASb,CAAA,IAAW;UAC1B,MAAMC,CAAA,GAAgBjD,CAAA,CAAwB;YAC5CE,QAAA,EAAAiC,CAAA;YACAhC,UAAA,EAAAkC,CAAA;YACAjC,KAAA,EAAAnH,CAAA;YACAoH,WAAA,EAAAtB,CAAA;YACAuB,KAAA,EAAAsC,CAAA;YACArC,MAAA,EAAAyC,CAAA;YACAxC,eAAA,EAAApH,CAAA;YACAqH,SAAA,EAAA6B,CAAA;YACA5B,YAAA,EAAArH,CAAA;YACAsH,QAAA,EAAAhG;UAAA,CACD;UAED4G,CAAA,CACEe,CAAA,EACAE,CAAA,EACAS,CAAA,EACAjJ,CAAA,EACA,GAAGV,CAAgB,IAAI0J,CAAM,IAC7B7J,CAAA,EACA6J,CACF;QAAA,CACD;MACH;IAIF;EAEJ;EAEac,EAAA,GAAoBC,CAC/B/J,CAAA,EACAC,CAAA,EACAK,CAAA,KACkC;IP5HpC,IAAAK,CAAA;IO6HE,MAAMtB,CAAA,GAAsB8H,CAAA,CAC1BnH,CACF;IAGI,IAAAX,CAAA,CAAoBqK,GAAA,IAAO,WAAYrK,CAAA,EAA4C;MACrF,MAAMkD,CAAA,GAAalD,CAAA;MACf,OAACsB,CAAA,GAAA4B,CAAA,CAAWmH,GAAA,KAAX,QAAA/I,CAAA,CAAgBqJ,uBAAA,GACZ,OAAAzH,CAAA;MAEH;UACJyH,uBAAA,EAAyB;YAAE5B,UAAA,EAAAjJ,CAAA;YAAY4I,gBAAA,EAAA7E;UAAiB;QAAA,IACtDX,CAAA,CAAWmH,GAAA;QACT;UAAEO,KAAA,EAAA9G,CAAA;UAAO6D,QAAA,EAAA/H;QAAA,IAAasD,CAAA;MAEtBY,CAAA,CAAA0G,OAAA,CAAS9E,CAAA,IACbyE,CAAA,CAAczE,CAAA,EAAQ5F,CAAA,EAAY+D,CAAA,EAAkBjD,CAAA,EAAcK,CAAQ,CAC5E,GACIrB,CAAA,IAAYA,CAAA,CAASiL,KAAA,IACvBjL,CAAA,CAASiL,KAAA,CAAML,OAAA,CAAS9E,CAAA,IACtByE,CAAA,CAAczE,CAAA,EAAO5F,CAAA,EAAY+D,CAAA,EAAkBjD,CAAA,EAAcK,CAAQ,CAC3E,GAEErB,CAAA,IAAYA,CAAA,CAASkL,KAAA,IACvBlL,CAAA,CAASkL,KAAA,CAAMN,OAAA,CAAS9E,CAAA,IACtByE,CAAA,CAAczE,CAAA,EAAO5F,CAAA,EAAY+D,CAAA,EAAkBjD,CAAA,EAAcK,CAAQ,CAC3E;IACF,OAEK;MACL,MAAMiC,CAAA,GAAQlD,CAAA;MACV,KAACkD,CAAA,CAAMmH,GAAA,CAAIM,uBAAA,EACb,OAAA3C,OAAA,CAAQO,KAAA,CAAM,4CAA4C,GACnDrF,CAAA;MAGTiH,CAAA,CACEjH,CAAA,EACAA,CAAA,CAAMmH,GAAA,CAAIM,uBAAA,CAAwB5B,UAAA,EAClC7F,CAAA,CAAMmH,GAAA,CAAIM,uBAAA,CAAwBjC,gBAAA,EAClC9H,CAAA,EACAK,CACF;IAAA;IAGK,OAAAjB,CAAA;EACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}